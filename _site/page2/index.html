<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Unhandled Expression &middot; Geoffroy Couprie – software security and architecture consultant
    
  </title>

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-117988815-1', 'auto');
  ga('send', 'pageview');
  </script>



  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png" />
<link rel="shortcut icon" href="/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="index">

    <div id="sidebar">
  <header>
    <img src="https://s.gravatar.com/avatar/ed9901b9b80743c05aedf58b4f4926dd?s=200" alt="self" />
    <h1 class="site-title">
      <a href="/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        Unhandled Expression
      </a>
    </h1>
    <p class="lead">Geoffroy Couprie – software security and architecture consultant</p>
  </header>
  <nav id="sidebar-nav-links">
  
    <a class="home-link "
        href="/">Home</a>
  
  

  

  


  
    
  

  
    
      <a class="page-link "
          href="/about.html">About</a>
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  


  
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/architecture.html">Architecture</a>
    
  

  
    
      <a class="category-link "
          href="/category/crypto.html">Crypto</a>
    
  

  
    
      <a class="category-link "
          href="/category/development.html">Development</a>
    
  

  
    
  

  

  
    
      <a class="category-link "
          href="/category/rust.html">Rust</a>
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/security.html">Security</a>
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/videolan.html">VideoLAN</a>
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  <nav id="sidebar-icon-links">
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/tags.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  
    <a id="search-link"
       class="icon"
       title="Search" aria-label="Search"
       href="/search.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
    </a>
  

  <!-- Optional additional links to insert for icons links -->
</nav>
  <a class="category-link active" href="https://www.patreon.com/geoffroy">Support my work on Patreon</a>
  <!--<p>
  &copy; 2018.
  <a href="/LICENSE.md">MIT License.</a>
</p>
-->
</div>


    <main class="container">
      <div class="content">
  
<div class="pagination">
  <a class="pagination-item newer"
     href="/">
    Newer
  </a>
</div>



  

  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/general/rust/2017/07/12/how-to-rewrite-you-project-in-rust.html">
        How to rewrite your project in Rust
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">12 Jul 2017</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        General
      
    
      &bull;

      
      
      

      
        <a href="/category/rust.html">
          Rust
        </a>
      
    
  </span>
</div>

    
      <p>In a <a href="https://unhandledexpression.com/2017/07/10/why-you-should-actually-rewrite-it-in-rust/">previous post</a>, I explained why rewriting existing software in Rust could be a good idea. The main point being that you should not rewrite the whole application, but replace the weaker parts without disturbing most of the code, to strengthen the codebase without disruption.</p>
<p>I also provided pointers to projects where other people and I did it succesfully, but without giving too many details. So let's get a real introduction to Rust rewrites now. This article requires a little bit of knowledge about Rust, but you should be able to follow it even as a<br />
beginner.</p>
<p>As a reminder, here are the benefits Rust bring into a rewrite:</p>
<ul>
<li>it can easily call C code</li>
<li>it can easily be called by C code (it can export C compatible functions and structures)</li>
<li>it does not need a garbage collector</li>
<li>if you want, it does not even need to handle allocations</li>
<li>the Rust compiler can produce static and dynamic libraries, and even object files</li>
<li>the Rust compiler avoids most of the memory vulnerabilities you get in C (yes, I had to mention it)</li>
<li>Rust is easier to maintain than C (this is discutable, but not the point of this article)</li>
</ul>
<p>As it turns out, this is more or less the plan to replace C code with Rust:</p>
<ul>
<li>import C structures and functions in Rust</li>
<li>import Rust structures and functions from C</li>
<li>reuse the host application's memory allocations whenever possible</li>
<li>write code (yes, we have to do it at some point)</li>
<li>produce artefacts that can be linked with the host application</li>
<li>integrate with the build system</li>
</ul>
<p>We'll see how to apply this with examples from the Rust VLC plugin.</p>
<h2>Import C structures and functions in Rust</h2>
<p>Rust can easily use C code directly, by writing functions and structures definitions. A lot of the techniques you would use for this come from the <a href="https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html">"unsafe Rust" chapter</a> of "The Rust Programming Language" book. For the following C code:</p>
<p>[code lang=C]<br />
struct vlc_object_t {<br />
    const char   *object_type;<br />
    char         *header;<br />
    int           flags;<br />
    bool          force;<br />
    libvlc_int_t *libvlc;<br />
    vlc_object_t *parent;<br />
};<br />
[/code]</p>
<p>You would get the following Rust structure:</p>
<p>[code lang=C]<br />
extern crate libc;<br />
use libc::c_char;</p>
<p>#[repr(C)]<br />
pub struct vlc_object_t {<br />
  pub psz_object_type: *const c_char,<br />
  pub psz_header:      *mut c_char,<br />
  pub i_flags:         c_int,<br />
  pub b_force:         bool,<br />
  pub p_libvlc:        *mut libvlc_int_t,<br />
  pub p_parent:        *mut vlc_object_t,<br />
}<br />
[/code]</p>
<p>the <code>#[repr(C)]</code> tag indicates to the compiler that the structure should have a memory layout similar to the one generated by a C<br />
compiler. We import types from the libc crate, like <code>c_char</code>. Those types are platform dependent (with their different form already handled in libc). Here, we use a lot of raw pointers (indicated by <code>*</code>), which means by using this structure directly, we're basically writing C, which is no good! A good approach, as we'll see later, is to write safer wrappers above those C bindings.</p>
<p>Importing C functions is quite straightforward too:</p>
<p>[code lang=C]<br />
ssize_t  vlc_stream_Peek(stream_t *, const uint8_t **, size_t);<br />
ssize_t  vlc_stream_Read(stream_t *, void *buf, size_t len);<br />
uint64_t vlc_stream_Tell(const stream_t *);<br />
[/code]</p>
<p>These C function declarations would get translated to:</p>
<p>[code lang=C]<br />
#[link(name = &quot;vlccore&quot;)]<br />
extern {<br />
  pub fn vlc_stream_Peek(stream: *mut stream_t, buf: *mut *const uint8_t, size: size_t) -&gt; ssize_t;<br />
  pub fn vlc_stream_Read(stream: *mut stream_t, buf: *const c_void, size: size_t) -&gt; ssize_t;<br />
  pub fn vlc_stream_Tell(stream: *const stream_t) -&gt; uint64_t;<br />
}<br />
[/code]</p>
<p>The <code>#[link(name = "vlccore")]</code> tag indicates to which library we are linking. It is equivalent to passing a <code>-lvlccore</code> argument to the linker. Libvlccore is a library all VLC plugins must link to. Those functions are declared like regular Rust functions, but like the previous structures, will mainly work on raw pointers.</p>
<h3>bindgen</h3>
<p>You can always write all your bindings manually like this, but when the amount of code to import is a bit large, it can be a good idea to employ the awesome <a href="https://github.com/servo/rust-bindgen">bindgen</a> tool, that will generate Rust code from C headers.</p>
<p>It can work as a command line tool, but can also work at compile time from a <a href="http://doc.crates.io/build-script.html">build script</a>. First, add the dependency to your <code>Cargo.toml</code> file:</p>
<p>[code lang=toml]<br />
[build-dependencies.bindgen]<br />
version = &quot;^0.25&quot;<br />
[/code]</p>
<p>You can then write your build script like this:</p>
<p>[code lang=C]<br />
extern crate bindgen;<br />
use std::fs::File;<br />
use std::io::Write;<br />
use std::path::Path;</p>
<p>fn main() {<br />
  let include_arg = concat!(&quot;-I&quot;, env!(&quot;INCLUDE_DIR&quot;));<br />
  let vlc_common_path = concat!(env!(&quot;INCLUDE_DIR&quot;), &quot;/vlc_common.h&quot;);</p>
<p>  let _ = bindgen::builder()<br />
    .clang_arg(include_arg)<br />
    .clang_arg(&quot;-include&quot;)<br />
    .clang_arg(vlc_common_path)<br />
    .header(concat!(env!(&quot;INCLUDE_DIR&quot;), &quot;/vlc_block.h&quot;))<br />
    .hide_type(&quot;vlc_object_t&quot;)<br />
    .whitelist_recursively(true)<br />
    .whitelisted_type(&quot;block_t&quot;)<br />
    .whitelisted_function(&quot;block_Init&quot;)<br />
    .raw_line(&quot;use ffi::common::vlc_object_t;&quot;)<br />
    .use_core()<br />
    .generate().unwrap()<br />
    .write_to_file(&quot;src/ffi/block.rs&quot;);<br />
}<br />
[/code]</p>
<p>So there's a lot to unpack here, because bindgen is very flexible:</p>
<ul>
<li>we use <code>clang_arg</code> to pass the include folder path and pre include a header everywhere (<code>vlc_common.h</code> is included pretty puch everywhere in VLC)</li>
<li>the <code>header</code> method specifies the header from which we will import definitions</li>
<li><code>hide_type</code> prevents redefinition of elements we already defined (liek the ones from the common header)</li>
<li><code>whitelisted_type</code> and <code>whitelisted_function</code> specify types and functions for which bindgen will create definitions</li>
<li><code>raw_line</code> writes its argument at the top of the file. I apply it to reuse definitions from other files</li>
<li><code>write_to_file</code> writes the whole definition to the specified path</li>
</ul>
<p>You can apply that process to any C header you must import. With the build script, it can run every time the library is compiled, but be careful, generating a lot of headers can take some time. It might be a good idea to pregenerate them and commit the generated files, and update them from time to time.</p>
<p>It is usually a good idea to separate the imported definitions in another crate with the <code>-sys</code> suffix, and write the safe code in the main crate.<br />
As an example, see the crates <a href="https://crates.io/crates/openssl">openssl</a> and <a href="https://crates.io/crates/openssl-sys">openssl-sys</a>.</p>
<h3>Writing safe wrappers</h3>
<p>Previously, we imported the C function <code>ssize_t vlc_stream_Read(stream_t *, void *buf, size_t len)</code> as the Rust version <code>pub fn vlc_stream_Read(stream: *mut stream_t, buf: *const c_void, size: size_t) -&amp;gt; ssize_t</code> but kept an unsafe interface. Since we want to use those functions safely, we can now make a better wrapper:</p>
<p>[code lang=C]<br />
use ffi;</p>
<p>pub fn stream_Read(stream: *mut stream_t, buf: &amp;mut [u8]) -&gt; ssize_t {<br />
  unsafe {<br />
    ffi::vlc_stream_Read(stream, buf.as_mut_ptr() as *mut c_void, buf.len())<br />
  }<br />
}<br />
[/code]</p>
<p>Here we replaced the raw pointer to memory and the length with a mutable slice. We still use a raw pointer to the <code>stream_t</code> instance, maybe we can do better:</p>
<p>[code lang=C]<br />
use ffi;</p>
<p>pub struct Stream(*mut stream_t);</p>
<p>pub fn stream_Read(stream: Stream, buf: &amp;mut [u8]) -&gt; ssize_t {<br />
  unsafe {<br />
    ffi::vlc_stream_Read(stream.0, buf.as_mut_ptr() as *mut c_void, buf.len())<br />
  }<br />
}<br />
[/code]</p>
<p>Be careful if you plan to implement <a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>Drop</code></a> for this type: is the Rust code supposed to free that object? Is there some reference counting involved? Here is an example of <code>Drop</code> implementation from the openssl crate:</p>
<p>[code lang=C]<br />
pub struct SslContextBuilder(*mut ffi::SSL_CTX);</p>
<p>impl Drop for SslContextBuilder {<br />
    fn drop(&amp;mut self) {<br />
        unsafe { ffi::SSL_CTX_free(self.as_ptr()) }<br />
    }<br />
}<br />
[/code]</p>
<p>Remember that it's likely the host application has a lot of infrastructure to keep track of memory, and as a rule, we should reuse the tools it offers for the code at the interface between Rust and C. See the <a href="http://jakegoulding.com/rust-ffi-omnibus/">Rust FFI omnibus</a> for more examples of safe wrappers you can write.</p>
<p><em>Side note: as of now (2017/07/10) <a href="https://github.com/rust-lang/rust/issues/32838">custom allocators</a> are still not stable</em></p>
<h2>Exporting Rust code to be called from C</h2>
<p>Since the host application is written in C, it might need to call your code. This is quite easy in Rust: you need to write unsafe wrappers.</p>
<p>Here we will use as example the <a href="https://github.com/Geal/rust-devoxx2016">inverted index library for mobile apps</a> I wrote for a conference. In this library, we have an <code>Index</code> type that we want to use from Java. Here is its definition:</p>
<p>[code lang=C]<br />
#[repr(C)]<br />
pub struct Index {<br />
  pub index: HashMap&lt;String, HashSet&lt;i32&gt;&gt;,<br />
}<br />
[/code]</p>
<p>This type has a few method we want to provide:</p>
<p>[code lang=C]<br />
impl Index {<br />
  pub fn new() -&gt; Index {<br />
    Index {<br />
      index: HashMap::new(),<br />
    }<br />
  }</p>
<p>  pub fn insert(&amp;mut self, id: i32, data: &amp;str) {<br />
    [...]<br />
  }</p>
<p>  pub fn search_word(&amp;self, word: &amp;str) -&gt; Option&lt;&amp;HashSet&lt;i32&gt;&gt; {<br />
    self.index.get(word)<br />
  }</p>
<p>  pub fn search(&amp;self, text: &amp;str) -&gt; HashSet&lt;i32&gt; {<br />
    [...]<br />
  }<br />
}<br />
[/code]</p>
<p>First, we need to write the functions to allocate and deallocate our index. Every use from C will be wrapped in a <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>.</p>
<p>[code lang=C]<br />
#[no_mangle]<br />
pub extern &quot;C&quot; fn index_create() -&gt; *mut Index {<br />
  Box::into_raw(Box::new(Index::new()))<br />
}<br />
[/code]</p>
<p>The <code>Box</code> type indicates and owns a heap allocation. When the box is dropped, the underlying data is dropped as well and the memory is freed. The following function takes ownership of its argument, so it is dropped at the end.</p>
<p>[code lang=C]<br />
#[no_mangle]<br />
pub extern &quot;C&quot; fn index_free(ptr: *mut Index) {<br />
    let _ = unsafe { Box::from_raw(ptr) };<br />
}<br />
[/code]</p>
<p>Now that allocation is handled, we can work on a real method. The following method takes an index, and id for a text, and the text itself, as a C string (ie, terminated by a null character).</p>
<p>Since we're kinda writing C in Rust here, we have to first check if the pointers are null. Then we can transform the C string in a slice. Then we check if it is correctly encoded as UTF-8 before inserting it into our index.</p>
<p>[code lang=C]<br />
#[no_mangle]<br />
pub extern &quot;C&quot; fn index_insert(index: *mut Index, id: i32, raw_text: *const c_char) {<br />
  unsafe { if index.is_null() || raw_text.is_null() { return } };<br />
  let slice = unsafe { CStr::from_ptr(raw_text).to_bytes() };<br />
  if let Ok(text) = str::from_utf8(slice) {<br />
    (*index).insert(id, text);<br />
  }<br />
}<br />
[/code]</p>
<p>Most of the code for those kinds of wrappers is just there to transform between C and Rust types and checking that the arguments coming from C code are correct. Even if we have to trust the host application, we should program defensively at the boundary.</p>
<p>There are <a href="https://github.com/Geal/rust-devoxx2016/blob/master/inverted_index/src/lib.rs#L96-L121">other methods we could implement</a> for the index, we'll leave those as exercise for the reader :)</p>
<p>Now, we need to write the C definitions to import those functions and types:</p>
<p>[code lang=C]<br />
typedef struct Index Index;</p>
<p>Index* index_create();<br />
void   index_free(Index* index);<br />
void   index_insert(Index* index, int32_t id, char const* raw_text);<br />
[/code]</p>
<p>We defined <code>Index</code> as an opaque type here. Since Rust structures can be compatible with C structures, we could export the real type, but since it only contains a Rust specific type, <code>HashMap</code>, it is better to hide it completely and write accessors and wrappers.</p>
<h3>Generating bindings with rusty-cheddar</h3>
<p>Writing function imports from C to Rust is tedious, so we have bindgen for this. We also have a great tool to go the other way: <a href="https://github.com/Sean1708/rusty-cheddar">rusty-cheddar</a>.</p>
<p>In the same way, it can be used from a build script:</p>
<p>[code lang=C]<br />
extern crate cheddar;</p>
<p>fn main() {<br />
  cheddar::Cheddar::new().expect(&quot;could not read definitions&quot;)<br />
    .run_build(&quot;include/main.h&quot;);<br />
  cheddar::Cheddar::new().expect(&quot;could not read definitions&quot;)<br />
    .module(&quot;index&quot;).expect(&quot;malformed module path&quot;)<br />
    .insert_code(&quot;#include \&quot;main.h\&quot;&quot;)<br />
    .run_build(&quot;include/index.h&quot;);<br />
}<br />
[/code]</p>
<p>Here we run rusty-cheddar a first time without specifying the module: it will default to generate a header for the definitions in <code>src/lib.rs</code>.<br />
The second run specifies a different module, and can insert a file inclusion at the top.</p>
<p>It can be a good idea to commit the generated headers, since you will see immediately if you changed the interface in a breaking way.</p>
<h2>Integrating with the build system</h2>
<p>As you might know, we can make dynamic libraries and executables with rustc and cargo. But often, the host application will have its own build system, and it might disagree with the way cargo builds its projects. So we have multiple strategies:</p>
<ul>
<li>build Rust code separately, store libraries and headers in Maven or something (don't laugh, I've worked with such a system once, and it was actually great)</li>
<li>try to let rustc build dynamic libraries from inside the build system. We tried that for VLC and it was not great at all</li>
<li>build a static library from inside or outside the build system, include it in the libraries at link. This was done in <a href="https://github.com/rusticata/rusticata">Rusticata</a></li>
<li>build an object file and let the build system link it. This is what we ended up doing with VLC</li>
</ul>
<p>Building a static library is as easy as specifying <code>crate-type = ["staticlib"]</code> in your <code>Cargo.toml</code> file. To build an object file, use the command <code>cargo rustc --release -- --emit obj</code>. You can see how we added it to the <a href="https://github.com/Geal/vlc/blob/rust/modules/demux/Makefile.am#L464-L477">autotools usage in VLC</a>.</p>
<p>Unfortunately, for this part we still do not have automated ways to fix the issues. Maybe with some time, people will write scripts for autotools,<br />
CMake and others to handle Rust and Cargo.</p>
<p><em>Side note on reproducible builds: if you want to fix the set of Rust dependencies used in your project and make them always available, you can use <a href="https://github.com/alexcrichton/cargo-vendor">cargo-vendor</a> to store them in a specific folder</em></p>
<p>As you might have guessed, this is the most complex part, for which I have no good generic answer. I'd recommend that you spend the most time on this during the project's prototyping phase: import very little C code, export very little Rust code, try to make it build entirely from within the host application's build system. Once this is done, extending the project will get much easier. You really don't want to discover this task at the end of your project and try to retrofit your code in there.</p>
<h2>Going further</h2>
<p>While this article just explores the surface of Rust rewrites, I hope it provides a good starting point on the tools and techniques you can apply.<br />
Any rewrite will be a large and complex project, but the result is worth the effort. The code you will write will be stronger, and Rust's type system will force you to review the assumptions made in the C version. You might even find better ways to write it once you start refactoring your code in a more Rusty way, safely hidden behind your wrappers.</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/rust/2017/07/10/why-you-should-actually-rewrite-it-in-rust.html">
        Why you should, actually, rewrite it in Rust
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">10 Jul 2017</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/rust.html">
          Rust
        </a>
      
    
  </span>
</div>

    
      <p>You might have seen those obnoxious "you should rewrite it in Rust comments" here and there:</p>
<ul>
<li>in a <a href="https://transitiontech.ca/random/RIIR">blogpost</a></li>
<li>in a <a href="https://github.com/fc00/go-fc00/issues/1">Github issue</a></li>
<li>you might have heard about <a href="http://n-gate.com/hackernews/2017/02/21/0/">that Rust Evangelism Strike Force</a></li>
<li>it even has a joke <a href="https://twitter.com/rustevangelism">twitter account</a></li>
</ul>
<p>It's like at every new memory vulnerability in well known software, there’s that one person saying Rust would have avoided the issue. We get it, it’s annoying, and it does not help us grow Rust. This attitude is generally frowned upon in the Rust community. You can't just show up into someone’s project telling them to rewrite everything.</p>
<p>so, why am I writing this? Why would I try to convince you, now, that you should actually rewrite your software in Rust?</p>
<p>That's because I have been working on this subject for a long time now:</p>
<ul>
<li>I did <a href="https://www.youtube.com/watch?v=YTy_JOxGOd4">multiple</a> <a href="https://www.youtube.com/watch?v=e92Yrp3W_2I">talks</a> on it  </li>
<li>I even co-wrote a <a href="http://spw17.langsec.org/papers.html#parsers2017">paper</a></li>
<li>I did it both as client and personal work</li>
</ul>
<p>So, I'm commited to this, and yes, I believe you should rewrite some code in Rust. But there's a right way to do it.</p>
<h2>Why rewrite stuff?</h2>
<p>Our software systems are built on sand. We got pretty good at maintaining and fixing them over the years, but the cracks are showing. We still have not fixed definitely most of the low level vulnerabilities: stack buffer overflow (yes, those still exist), heap overflow, use after free, double free, off by one; the list goes on. We have some tools, like DEP, ASLR, stack canaries, control flow integrity, fuzzing. Large projects with funding, like Chrome, can resort to sandboxing parts of their application. The rest of us can still run those applications inside a virtual machine. This situation will not improve. <strong>There's a huge amount of old (think 90s), bad quality, barely maintained code that we reuse everywhere endlessly</strong>. The good thing with hardware is that at some point, it gets replaced. Software just gets copied again. Worse, with the development of IoT, a lot of the code that ships will never be updated. It's likely that some of those old libraries will still be there 15, 20 years from now.</p>
<p>Let's not shy away from the issue here. Most of those are written in C or C++ (and usually an old version). It is well known that it is hard to write correct, reliable software in those languages. Think of all the security related things you have to keep track of in a C codebase:</p>
<ul>
<li>pointer arithmetic</li>
<li>allocations and deallocations</li>
<li>data is mutable by default</li>
<li>functions return integers to mean pointers and error codes. Errors can be implicitely ignored</li>
<li>type casts, overflows and underflows are hard to track</li>
<li>buffer bounds in indexing and copying</li>
<li><a href="https://blog.regehr.org/archives/1520">all the undefined behaviours</a></li>
</ul>
<p>Of course, some developers can do this work. Of course, there are sanitizers. But it's an enormous effort to perform everyday for every project.</p>
<p>Those languages are well suited for low level programming, but require extreme care and expertise to avoid most of those issues. And even then, we assume the developers will always be well rested, focused and careful. We're only humans, after all. Note that in 2017, there are still people claiming that a C developer with sufficient expertise would avoid all those issues. It's time we put this idea to rest. Yes, some projects can avoid a lot of vulnerabilities, with a team of good developers, frequent code reviews, a restricted set of features, funding, tools, etc. Most projects cannot. And as I said earlier, a lot of the code is not even maintained.</p>
<p>So we have to do something. We must make our software foundations stronger. That means fixing operating systems, drivers, libraries, command line tools, servers, everything. We might not be able to fix most of it today, or the next year, but maybe 10 years from now the situation will have improved.</p>
<p>Unfortunately, we cannot rewrite everything. If you ever attempted to rewrite a project from scratch, you'd know that while you can avoid some of the mistakes you made before, you will probably <a href="https://daniel.haxx.se/blog/2017/03/27/curl-is-c/">introduce a lot of regressions and new bugs</a>. It's also wrong on the human side: if there are maintainers for the projects, they would need to work on the new and old one at the same time. Worse, you would have to teach them the new approach, the new language (which they might not like), and plan for an upgrade to the new project for all users.</p>
<p>This is not doable, and this is the part most people asking for project rewrites in Rust do not understand. What I'm advocating for is much simpler: <strong>surgically replace weaker parts but keep most of the project intact</strong>.</p>
<h2>How</h2>
<p>Most of the issues will happen around IO and input data handling, so it makes sense to focus on it. It happens there because that's where the code manipulates buffers, parsers, and uses a lot of pointer calculations. It is also the least interesting part for software maintainers, since it is usually not where you add useful features, business logic, etc. And this logic is usually working well, so you do not want to replace it. If we could rewrite a small part of an application or library without disrupting the rest of the code, we would get most of the benefits without the issues of a full rewrite. It is the exact same project, with the same interface, same distribution packaging as before, same developer team. We would just make an annoying part of the software stronger and more maintainable.</p>
<p>This is where Rust comes in. It is focused on providing memory safety, thread safety while keeping the code performant and the developer productive. As such, it is generally easier to get safe, reliable code in production while writing basic Rust, than a competent, well rested C developer using all the tools available could do.</p>
<p>Most of the other safe languages have strong requirements, like a runtime and a garbage collector. And usually, they expect to be the host application (how many languages assume they will handle the process's entry point?). Here, we are guests in someone else's house. We must integrate nicely and quietly.</p>
<p>Rust is a strong candidate for this because:</p>
<ul>
<li>it can easily call C code</li>
<li>it can easily be called by C code (it can export C compatible functions and structures)</li>
<li>it does not need a garbage collector</li>
<li>if you want, it does not even need to handle allocations</li>
<li>the Rust compiler can produce static and dynamic libraries, and even object files</li>
<li>the Rust compiler avoids most of the memory vulnerabilities you get in C (yes, I had to mention it)</li>
</ul>
<p>So you can actually take a piece of C code inside an existing project, import the C structures and functions to access them from Rust, rewrite the code in Rust, export the functions and structures from Rust, compile it and link it with the rest of the project.</p>
<p>If you don't believe it's possible, take a look at these two examples:</p>
<ul>
<li><a href="https://github.com/rusticata/rusticata">Rusticata</a> integrates Rust parsers written with nom in Suricata, an intrusion detection system</li>
<li>a <a href="https://github.com/geal/rust-vlc-demux">VLC media player plugin</a> to parse FLV files, written entirely in Rust </li>
</ul>
<p>You get a lot of benefits from this approach. First, Rust has great package management with Cargo and crates.io. That means you can separate some of the work in different libraries. See as an example the <a href="https://github.com/rusticata">list of parsers</a> from the Rusticata project. You can test them independently, and even reuse them in other projects. The <a href="https://github.com/rust-av/flavors">FLV parser</a> I wrote for VLC can also work in a <a href="https://github.com/sdroege/gst-plugin-rs/tree/master/gst-plugin-flv">Rust GStreamer plugin</a> You can also make a separate library for the glue with the host application. I'm working on <a href="https://github.com/Geal/vlc_module.rs">vlc_module</a> exactly for that purpose: making Rust VLC plugins easier to write.</p>
<p>This approach works well for applications with a plugin oriented architecture, but you can also rewrite core parts of an application or library. The biggest issue is high coupling of C code, but it is usually easy to rewrite bit by bit by keeping a common interface. Whenever you have rewritten some coupled parts of of a project, you can take time to refactor it in a more Rusty way, and leverage the type system to help you. A good example of this is the <a href="https://github.com/carols10cents/rust-out-your-c-talk">rewrite of the Zopfli library from C to Rust</a>.</p>
<p>This brings us to another important part of that infrastructure rewrite work: while we can rewrite part of an existing project without being too intrusive, we can also rewrite a library entirely, keeping exactly the same C API. You can have a Rust library, dynamic or static, with the exact same C header, that you could import in a project to replace the C one. This is a huge result. It's like replacing a load-bearing wall in an existing building. This is not an easy thing to realize, but once it's done, you can improve a lot of projects at once, provided your distribution's package manager supports that replacement, or other projects take the time to upgrade.</p>
<p>This is a lot of work, but every time we advance a little, everybody can benefit from it, and it will add up over the years. So we might as well start now.</p>
<p>Currently, I'm focused on VLC. This is a good target because it's a popular application that's often part of the basic stack of any computer (browser, office suite, media player). So it's a big target. But take a look at the list of dependencies in most web applications, or the dependency graph of common distributions. There is a lot of low hanging fruit there.</p>
<p>Now, how would you actually perform those rewrites? You can <a href="https://unhandledexpression.com/2017/07/12/how-to-rewrite-you-project-in-rust/">check out the next post</a> and <a href="http://spw17.langsec.org/papers/chifflier-parsing-in-2017.pdf">the paper explaining how we did it in Rusticata and VLC</a>.</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/general/rust/security/2016/11/25/this-year-in-nom-2-0-is-here.html">
        This year in nom: 2.0 is here!
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">25 Nov 2016</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        General
      
    
      &bull;

      
      
      

      
        <a href="/category/rust.html">
          Rust
        </a>
      
    
      &bull;

      
      
      

      
        <a href="/category/security.html">
          Security
        </a>
      
    
  </span>
</div>

    
      <p>Nearly one year ago, on November 15th 2015, I released the 1.0 version of <a href="https://github.com/Geal/nom">nom, the fast parser combinators library</a> I wrote in <a href="http://rust-lang.org/">Rust</a>. A lot happened around that project, and I have been really happy to interact with nom users around the world.</p>
<p><!--more--></p>
<p>TL;DR: it's new nom day! The 2.0 release is here! Read the <a href="https://github.com/Geal/nom/blob/master/CHANGELOG.md">changelog</a>. Follow the <a href="https://github.com/Geal/nom/blob/ca1398538b0050b4009f67151063405766e0c84f/doc/upgrading_to_nom_2.md">upgrade documentation</a> if it breaks stuff.</p>
<p><img class="aligncenter size-full wp-image-954" src="/assets/celebrate.gif" alt="celebrate" width="499" height="285" /></p>
<h2>Interesting usage</h2>
<p>I wouldn't be able to list <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=filename%3ACargo.toml+nom">all the projects using nom</a> on this page, even <a href="https://crates.io/crates/nom/reverse_dependencies">the subset present on crates.io</a>, but here are a few examples of what people built with nom:</p>
<ul>
<li><a href="https://crates.io/crates/semver">semver</a> briefly shipped with nom in February thanks to <a href="http://twitter.com/steveklabnik">Steve Klabnik</a>, until he replaced it with a regexp based solution (no hard feelings, I'd have done the same)</li>
<li><a href="https://github.com/joelself/tomllib">tomllib</a>, a complete TOML implementation written by <a href="https://twitter.com/JoelSelf">Joel Self</a></li>
<li>a <a href="https://github.com/maxmcc/rust-jvm">JVM</a>, because why not! Great work coming from a team of students at the University of Pennsylvania</li>
<li><a href="https://github.com/tagua-vm/parser">Tagua VM</a>, a great PHP implementation in Rust by <a href="https://twitter.com/mnt_io">Ivan Enderlin</a></li>
<li> <a href="https://github.com/dtolnay/syn">syn</a>, the Rust item parser written by <a href="https://github.com/dtolnay">David Tolnay</a> everybody uses with the <a href="https://github.com/rust-lang/rfcs/blob/master/text/1681-macros-1.1.md">macros 1.1 feature</a> to generate code from structures or enums, <a href="https://github.com/dtolnay/syn/blob/7184b1381ea1552cd02336775a6fbf47e4bc9dfc/src/nom.rs">actually ships with its own fork of nom</a>! It was forked to remove the incomplete data handling, and reduce compilation times</li>
<li><a href="https://github.com/deech/shen-rust">shen-rust</a>, a complete implementation of the Shen language in Rust that was <a href="https://www.thestrangeloop.com/2016/rusty-runtimes-building-languages-in-rust.html">presented at Strangeloop 2016</a> by <a href="https://twitter.com/deech">Aditya Siram</a></li>
<li><a href="https://github.com/rusticata">a series of parsers (DER, NTP, SNMP, IPSec, TLS)</a> were developed for its integration in the <a href="https://suricata-ids.org/">Suricata</a> network analysis tool. This work was presented at <a href="http://suricon.net/wp-content/uploads/2016/11/SuriCon2016_PierreChifflier.pdf">Suricon 2016</a> by <a href="https://twitter.com/pollux7">Pierre Chifflier</a></li>
</ul>
<p>And a lot of other projects. As a side note, people apparently like to build parsers for flac, bittorrent and bitcoin stuff, LISP and Scheme tokenizers and, oddly, ASN.1 libraries :D</p>
<p>I have been really humbled by what people achieved with this little library, and I hope it will enable even more awesome projects!</p>
<h2>Growth and stabilization</h2>
<p>The goal before 1.0 was to get a usable parsing library, and after 1.0, to <a href="https://github.com/Geal/nom/blob/master/CHANGELOG.md">add features people were missing</a> and explore new ideas. A lot of code was contributed for bitstream and string parsing, and adding a lot of useful combinators like "peek!", "separated_list!" or "tuple!".</p>
<p>Unfortunately, a few parts of nom got increasingly painful to maintain and support, so the 2.0 was a good opportunity to clean them up, and add more features while we're at it.</p>
<p>The <a href="http://rust.unhandledexpression.com/nom/macro.chain!.html">"chain!" combinator</a>, which everybody uses to parse a sequence of things and accumulate the results in structs or tuple, is now deprecated, and will be replaced by <a href="http://rust.unhandledexpression.com/nom/macro.do_parse!.html">"do_parse!"</a>, a simpler alternative. There are also a lot of specific helpers to make your code nicer, like <a href="http://rust.unhandledexpression.com/nom/macro.pair!.html">"pair!"</a>, <a href="http://rust.unhandledexpression.com/nom/macro.preceded!.html">"preceded!"</a>, <a href="http://rust.unhandledexpression.com/nom/macro.delimited!.html">"delimited!"</a>, <a href="http://rust.unhandledexpression.com/nom/macro.separated_pair!.html">"separated_pair!"</a>, <a href="http://rust.unhandledexpression.com/nom/macro.separated_list!.html">"separated_list!"</a> and <a href="http://rust.unhandledexpression.com/nom/macro.delimited!.html">"delimited!"</a>. Yes, I went to great lengths to make sure you stop using chain :)</p>
<p>The "length_value!" and other associated combinators were refactored, to have more sensible names and behaviours. "eof", eol" and the basic token parsers like "digit" or "alphanumeric" got the same treatment. Those can be a source of issues in the upgrade to 2.0, but if the new behaviour does not work in your project, replacing them is still easy with the "is_a!" combinator and others.</p>
<p>At last, I changed the name of the "error!" macro that was conflicting with the one from the log crate. I hoped that by waiting long enough, the log people would change their macro, but it looks like I lost :p</p>
<h2>New combinators</h2>
<p>A few new simple combinators are here:</p>
<ul>
<li>the previously mentioned "do_parse!" makes nicer code than "chain!":</li>
</ul>
<p>The "chain!" version uses this weird closure-like syntax (while not actually using a closure) with a comma ending the parser list:</p>
<pre>named!(filetype_parser&lt;&amp;[u8],FileType&gt;, 
 chain!( 
 m: brand_name ~ 
 v: take!(4) ~ 
 c: many0!(brand_name) , 
 ||{ FileType{
   major_brand: m,
   major_brand_version:v,
   compatible_brands: c
 } } 
));</pre>
<p>The "do_parse!" version only uses "&gt;&gt;" as separating token, and returns a value as a tuple. If the tuple contains only value, (A) is conveniently equivalent to A.</p>
<pre>named!(filetype_parser&lt;&amp;[u8],FileType&gt;, 
 do_parse!( 
   m: brand_name &gt;&gt; 
   v: take!(4) &gt;&gt; 
   c: many0!(brand_name) &gt;&gt; 
   (FileType{
     major_brand: m,
     major_brand_version:v,
     compatible_brands: c
   }) 
));</pre>
<p>"chain!" had too many features, like a "?" indicating a parser was optional (which you can now do with "opt!"), and you could declare one of the values as mutable. All of those and the awkward syntax made it hard to maintain. Still, it was one of the first useful combinators in nom, and it can now happily retire</p>
<ul>
<li><a href="http://rust.unhandledexpression.com/nom/macro.permutation!.html">"permutation!"</a> applies its child parser in any order, as long as all of them succeed once</li>
</ul>
<pre>  fn permutation() {
    named!(perm&lt;(&amp;[u8], &amp;[u8], &amp;[u8])&gt;,
      permutation!(tag!("abcd"), tag!("efg"), tag!("hi"))
    );

    let expected = (&amp;b"abcd"[..], &amp;b"efg"[..], &amp;b"hi"[..]);

    let a = &amp;b"abcdefghijk"[..];
    assert_eq!(perm(a), Done(&amp;b"jk"[..], expected));
    let b = &amp;b"efgabcdhijk"[..];
    assert_eq!(perm(b), Done(&amp;b"jk"[..], expected));
    let c = &amp;b"hiefgabcdjk"[..];
    assert_eq!(perm(c), Done(&amp;b"jk"[..], expected)
}</pre>
<p>This one was very interesting to write :)</p>
<ul>
<li><a href="http://rust.unhandledexpression.com/nom/macro.tag_no_case!.html">"tag_no_case!"</a> works like <a href="http://rust.unhandledexpression.com/nom/macro.tag!.html">"tag!"</a>, but compares independently from the case. This works great for ASCII strings, since the comparison requires no allocation, but the UTF-8 case is trickier, and I'm still looking for a correct way to handle it</li>
<li><a href="http://rust.unhandledexpression.com/nom/macro.named_attr!.html"><code>"</code>named_attr!"</a> creates functions like <a href="http://rust.unhandledexpression.com/nom/macro.named!.html">"named!"</a><code></code> but can add attributes like documentation. This was a big pain point, now nom parsers can have documentation generated by rustdoc</li>
<li><code></code>"<a href="http://rust.unhandledexpression.com/nom/macro.many_till!.html">many_till!"</a> applies repeatedly its first child parser until the second succeeds</li>
</ul>
<h2>Whitespace separated formats</h2>
<p>This is one of the biggest new additions, and a feature that people wanted for a long time. A lot of the other Rust parser libraries are designed with programming languages parsing in mind, while I started nom mainly to parse binary formats, like video containers. Those libraries usually handle whitespace parsing for you, and you only need to specify the different elements of your grammars. You essentially work on a list of already separated elements.</p>
<p>Previously, with nom, you had to explicitely parse the spaces, tabs and end of lines, which made the parsers harder to maintain. What we want in the following example is to recognize a "(", an expression, then a ")", and return the expression, but we have to introduce a lot more code:</p>
<pre>named!(parens&lt;i64&gt;, delimited!(
    delimited!(opt!(multispace), tag!("("), opt!(multispace)),
    expr,
    delimited!(opt!(multispace), tag!(")"), opt!(multispace))
  )
);</pre>
<p>This new release introduces <a href="http://rust.unhandledexpression.com/nom/macro.ws!.html">"ws!"</a>, a combinator that will automatically insert the separators everywhere:</p>
<pre>named!(parens&lt;i64&gt;, ws!(delimited!( tag!("("), expr, tag!(")") )) );</pre>
<p><img class="aligncenter size-full wp-image-953" src="/assets/magic.gif" alt="magic" width="350" height="196" />By default, it removes spaces, tabs, carriage returns and line feed, but you can easily specify your own separator parser and make your own version of "ws!".</p>
<p>This makes whitespace separated formats very easy to write. See for example the <a href="https://github.com/Geal/nom/blob/ac8fe712b9f8b3da661828ffc5b97a825007b590/tests/json.rs">quickly put together, probably not spec compliant JSON parser</a> I added as test.</p>
<p>If you're working on a language parsers, this should help you greatly.</p>
<h2>Architecture changes</h2>
<h3>Error management</h3>
<p>The error management system that accumulated errors and input positions as it backtracks through the parser tree is great for some projects like language parsers, but others were not using it and got a penalty because of vectors allocation and deallocation.</p>
<p>In the 2.0 release, this error management system is now activated by the "verbose-errors" feature. Projects that don't use it should build correctly right away, and their parsers could get 30% to 50% faster!</p>
<h3>Input types</h3>
<p>One of nom's original assumptions was that it should work on byte slices and strings instead of byte or char iterators, because the CPU likes contiguous data. As always, the reality is a bit more complex than that, but it worked well and made the code very simple: I only passed subslices from one parser to the next.</p>
<p>But I wrongly assumed that because of that design, nom could only work on contiguous data. <a href="https://twitter.com/carllerche">Carl Lerche</a> made the interesting point that there are few points where nom actually needs to read a serie of bytes or chars and those could accomodate other data structures like ropes or a list of buffers.</p>
<p>So I got to work on an abstraction for input types that would work for &amp;[u8] and &amp;str, but also for other types. In the process, I was able to factor most of the &amp;str specific combinators with the &amp;[u8] ones. This will make them easier to maintain in the future.</p>
<p>The result of that work is <a href="https://github.com/Geal/nom/blob/2e2730cdb451a555f68ff8cc27f852d3d292df42/src/traits.rs">a list of traits</a> that any input type should implement to be usable with nom. I <a href="https://github.com/Geal/nom/blob/2e2730cdb451a555f68ff8cc27f852d3d292df42/tests/blockbuf-arithmetic.rs#L17-L187">experimented a bit with the BlockBuf type</a>, and this approach looks promising. I expect that people will find cool applications for this, like parsers returning references to not yet loaded data, or blocking a coroutine on a tag comparison until the data is available.</p>
<h2>A smooth upgrade process</h2>
<p>For the 1.0 release, I choose a few projects using nom, and tried to build them to test the new version and document the upgrade. This was so useful that I did it again for 2.0, so if you're lucky, you maintain one of the 30 crates I tested, and you received a pull request doing that upgrade for you. Otherwise, I wrote <a href="https://github.com/Geal/nom/blob/ca1398538b0050b4009f67151063405766e0c84f/doc/upgrading_to_nom_2.md">an upgrade documentation</a> that you can follow to fix the migration issues. You're still lucky, though, because most crates will build (or only require a one line fix in Cargo.toml).</p>
<p><img class="aligncenter size-full wp-image-955" src="/assets/fixingstuff.gif" alt="fixingstuff" width="240" height="180" /></p>
<p>I'll write soon about that process and the benefits you can get by applying it to your projects.</p>
<h2>The future</h2>
<p>I have a lot of ideas for the next version, also a lot of pull requests to merge and issues to fix. Not everything could make it into the 2.0, otherwise I would never have released it.</p>
<p>In short, the plan:</p>
<ul>
<li>rewrite completely the producers and consumers system. It is not very usable right now. It could be replaced by an implementation based on futures</li>
<li>improve the performance. I got a good enough library by choosing the most naive solutions, but there are lots of points I could improve (especially in helping LLVM generate faster code)</li>
<li>implement a new serialization library. I believe there is some room for a serialization system that does not rely on automatic code generation, and it would go well with nom</li>
<li>continue my work on writing <a href="https://github.com/Geal/rust-vlc-demux">nom demuxers for VLC media player</a>. I have a good proof of concept, now I need to make it production ready</li>
<li>add new, interesting examples: indentation based programming languages, tokio integration, integration in high performance networking systems</li>
<li>I'll release very soon a large networking tool that relies heavily on nom. Expect some big news :)</li>
</ul>
<p>That's it, now go and upgrade your code, you'll enjoy this new version!</p>
<p>&nbsp;</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/development/general/rust/2016/04/14/using-llvm-pgo-in-rust.html">
        PoC: using LLVM's profile guided optimization in Rust
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">14 Apr 2016</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/development.html">
          Development
        </a>
      
    
      &bull;

      
      
      

      
        General
      
    
      &bull;

      
      
      

      
        <a href="/category/rust.html">
          Rust
        </a>
      
    
  </span>
</div>

    
      <h2><img class="aligncenter size-full wp-image-917" src="/assets/screen-shot-2016-04-14-at-15-50-01.png" alt="call graph" width="525" height="408" /></h2>
<h2>What does profile-guided optimization mean?</h2>
<p>Some languages have a JIT (Just In Time) compiler available at runtime, that can optimize the executed code depending on current execution patterns. This is, in large part, the cause of the performance of Lua and the JVM. They can start a bit slow, but by accumulating information on actual running code, they make it faster and faster for the current load. <a href="https://wingolog.org/pub/fosdem-2015-pflua-slides.pdf" target="_blank">PfLua</a> is a great example: the firewall rules are optimized again and again, until the current network traffic is handled as quickly as possible.</p>
<p>When you use other languages, such as C, you usually cannot optimize the application once it is compiled. Except when you use an optimization technique known as <em>Profile-Guided Optimization</em>. From <a href="https://en.wikipedia.org/wiki/Profile-guided_optimization" target="_blank">Wikipedia</a> :</p>
<blockquote><p>Profile-guided optimization (PGO, sometimes pronounced as pogo), also known as profile-directed feedback (PDF), is a compiler optimization technique in computer programming that uses profiling to improve program runtime performance.</p></blockquote>
<p>It relies on profiling the compiled application, while it runs with the expected, real world load (web traffic, calculations, etc), and feed this profiling information to the compiler. On the next build, the compiler will have more information on which parts of the program are less used, which branches are taken more often, the expected values in a range, etc. Instead of guessing how the program would behave to choose optimizations, the compiler has true information, and can optimize more precisely. There's one issue with the process: you need two compilations and a profiling run to generate the final executable. But it gets easier when you automate it, as we can see in the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Build_Instructions/Building_with_Profile-Guided_Optimization" target="_blank">Firefox build process</a>.</p>
<h2>PGO in LLVM</h2>
<p>While it has been available in other systems for a long time (Visual Studio 2005, the Intel compiler ICC for Itanium), <a href="http://llvm.org/devmtg/2013-11/slides/Carruth-PGO.pdf" target="_blank">it appeared recently in LLVM</a>.  It has since then been applied successfully to <a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/xcode_profile_guided_optimization/pgo-using/pgo-using.html" target="_blank">XCode (Objective C, Swift)</a> and <a href="https://wiki.dlang.org/LDC_LLVM_profiling_instrumentation" target="_blank">LDC, the D compiler</a>.</p>
<p>LLVM has a great feature: it uses an Intermediate Representation code (IR), which is a kind of high level assembly language. It applies its optimizations and machine code generation to that representation. If you make a compiler for a new language, targeting the LLVM IR will give you these features (nearly) for free.</p>
<p>In practice, compiler frontends choose which features they use, so you may not access everything LLVM has to offer. In particular, the Rust compiler, as of now (April 2016), provides a <em>llvm-args</em> option, but that option filters what you can send to LLVM, so we cannot use PGO here.</p>
<h2>PGO in Rust</h2>
<p>Still, with <em>rustc</em>, you can generate directly the IR, or its binary encoding, named bitcode:</p>
<blockquote><p>rustc --emit llvm-bc main.rs<br />
# or, with cargo:<br />
cargo rustc -- --emit llvm-bc</p></blockquote>
<p>The approach I tried here is to take that bitcode, and manually apply LLVM's transformations until I get a compiled executable. This is not really usable for now, especially because I chose an example with very few dependencies. With more dependencies, the compilation and linking will get more complex and unmanageable manually.</p>
<p>LLVM comes with a few commands that you can use to build code manually. The first one is <em>opt</em>, and it applies optimizations and instrumentation on the bitcode file (here, the file <em>target/release/pgo.bc</em>):</p>
<blockquote><p>opt-3.8 -O2 -pgo-instr-gen -instrprof target/release/pgo.bc -o pgo.bc</p></blockquote>
<p>The new bitcode file contains code to profile the end application (mainly by counting how often we use each code path). We can now convert that bitcode file to an object file, and link it using clang:</p>
<blockquote><p>llc-3.8 -O2 -filetype=obj pgo.bc<br />
clang-3.8 -O2 -flto -fprofile-instr-generate pgo.o -L/usr/local/lib/rustlib/x86_64-apple-darwin/lib -lstd-ca1c970e -o pgo</p></blockquote>
<p><strong>Note:</strong> I built my own rustc from source, so your <em>libstd</em> file may not have the same hash. Since Rust (as of April 2016) uses LLVM 3.7, we can use LLVM 3.8's PGO features, since the bitcode format is apparently backward compatible. I use OS X, and Homebrew's LLVM 3.8 has compilation issues, so I needed to build the compiler runtime from source. It's a proof of concept, not production code ;)</p>
<p>We will now run the program we just built, preferably with production data and traffic. It will automatically generate a <em>default.profraw</em> file, containing the profiling information. This file must be transformed to a format that <em>opt</em> will understand with <em>llvm-profdata</em>:</p>
<blockquote><p>llvm-profdata-3.8 merge -output=pgo.profdata default.profraw</p></blockquote>
<p>This <em>.profdata</em> file will now be used in the compilation steps:</p>
<blockquote><p>opt-3.8 -O2 -pgo-instr-use -pgo-test-profile-file=pgo.profdata target/release/pgo.bc -o pgo-opt.bc<br />
llc-3.8 -O2 -filetype=obj pgo-opt.bc<br />
clang-3.8 -O2 -flto -fprofile-instr-use=pgo.profdata pgo-opt.o -L/usr/local/lib/rustlib/x86_64-apple-darwin/lib -lstd-ca1c970e -o pgo-opt</p></blockquote>
<p>We now have an executable compiled using profiling information. Is it fast?</p>
<h2>The benchmarks</h2>
<p>The <a href="https://benchmarksgame.alioth.debian.org/u64q/program.php?test=nbody&amp;lang=rust&amp;id=2" target="_blank">program</a> I tested is a <a href="https://benchmarksgame.alioth.debian.org/u64q/nbody-description.html#nbody" target="_blank">n-body simulation</a>. It was a great test target since libstd is the only dependency, and the load factor depends on a number given as command line argument. Here is a test with time (I know it's not the most precise benchmarking tool, but for a tenth of second precision, it works alright):</p>
<blockquote><p>$ time ./target/release/pgo 1000000000<br />
-0.169075164<br />
-0.169051540</p>
<p>real    1m22.528s<br />
user    1m22.214s<br />
sys     0m0.173s</p>
<p>$ time ./pgo-opt 1000000000<br />
-0.169075164<br />
-0.169051540</p>
<p>real    1m9.810s<br />
user    1m9.687s<br />
sys     0m0.070s</p></blockquote>
<p>As it turns out, we gain nearly 15% in running time on this program. Other examples could have less impact, but this is encouraging! So, what happened inside our program?</p>
<h2>The generated code</h2>
<p>I provide assembly dumps of <a href="https://raw.githubusercontent.com/Geal/pgo-rust/master/assembly/pgo.s" target="_blank">the normal program, generated with <em>cargo --release</em></a>, and <a href="https://raw.githubusercontent.com/Geal/pgo-rust/master/assembly/pgo-opt.s" target="_blank">the one optimized with PGO</a>. Mostly, the code has been reordered, probably to fit better in cache lines. You can also consult PDF files with call graphs: <a href="http://dev.unhandledexpression.com/pgo.pdf" target="_blank">normal</a>, <a href="http://dev.unhandledexpression.com/pgo-opt.pdf" target="_blank">PGO optimized</a>.</p>
<p>The whole code for this article is <a href="https://github.com/Geal/pgo-rust" target="_blank">available here</a> if you want to reproduce the results or tinker with optimizations yourself.</p>
<p>This is a proof of concept, demonstrating that profile guided optimization could work in Rust. It is probably worthy of integration into <em>rustc</em>, but there's a lot of work before it could be usable. Still, there's <a href="https://github.com/rust-lang/rfcs/issues/1220" target="_blank">a github issue</a> where you can weigh in, if you would like this optimization in your applications.</p>
<p>&nbsp;</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/architecture/crypto/protocols/2015/10/01/crypto-problems-you-actually-need-to-solve.html">
        Crypto problems you actually need to solve
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">01 Oct 2015</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/architecture.html">
          Architecture
        </a>
      
    
      &bull;

      
      
      

      
        <a href="/category/crypto.html">
          Crypto
        </a>
      
    
      &bull;

      
      
      

      
        Protocols
      
    
  </span>
</div>

    
      <p>To follow up on the <a href="https://twitter.com/gcouprie/status/649166702278770688" target="_blank">small Twitter rant</a> that got people to explain GPG and OTR to me for a whole day, I'll explain the ideas behind this.</p>
<p><img class="aligncenter size-full wp-image-791" src="/assets/screen-shot-2015-10-01-at-14-08-49.png" alt="tweet rant screenshot" width="525" height="438" />There is always a new project around self hosting email and PGP, or building a new encrypted chat app. Let's say it aloud right now: those projects are not trying to improve the situation, they just want to build their own. Otherwise, they would help one of the 150 already existing projects. Worse, a lot of those try to build a business out of it, and end up making a system where you need to completely trust their business (as a side note, building a business is fine, but just be honest about your goals).</p>
<p>There are things that attract new projects, because the concept is easy to get, and this drives developers right into the "I'm smarter than everybody and can do better than existing projects" territory. But there's a reason they fail.</p>
<p>Making an encrypted chat app is solving the same problem as making a chat app -moving people off their existing platform, onto a new one- and additionally writing a safe protocol. Building a whole new infrastructure is not an easy task.</p>
<p>Making email and PGP easier to use is not only a UX issue. There is a complete mental model of how it works, what are the failure modes, and what are the trust levels. And you add above that the issues of email's metadata leaks, the lack of forward secrecy, the key management. Even with the simplest interface, it requires that the user builds that mental model, and that she understands other users may have different models. This is pervasive to the way PGP works. It has always been and will always be an expert's tool, and as such unfit to be deployed massively. You cannot solve infrastructure problems by teaching people.</p>
<blockquote><p>You cannot solve infrastructure problems by teaching people</p></blockquote>
<p>There is a pattern here: people want to build tools that will be the basis of safe communications for the years to come. Those are infrastructure problems, like electricity, running water or Internet access. They cannot be solved by teaching people how to use a tool. The tool has to work. They cannot be solved either by decentralization. At some point, someone has to pay for the infrastructure's maintenance. As much as I like the idea of decentralizing everything, this is not how people solve serious engineering problems. But the difference with other types of business is that infrastructure businesses are dumb pipes. They don't care what's running through them, and you can easily replace one with the other.</p>
<p>There is a strong need for "private by default", authenticated, anonymous communication. This will only come if the basic building blocks are here:</p>
<ul>
<li>multiparty Off-The-Record(or other protocols like Axolotl): forward secret communication currently only works in two-party communication. Adding more members and making the protocols safe against partitions is a real challenge</li>
<li>multidevice PGP (or alternate message encryption and authentication system): currently, to use PGP on multiple devices, either you synchronize all your private keys on all your devices, or you accept that some devices will not be able to decrypt messages. This will probably not work unless you have a live server somewhere, or at least some hardware device containing keys</li>
<li>redundant key storage: systems where a single key holds everything are very seducing, but they're a nightmare for common operation. You will lose the key. And the backup. And the other backup. You will end up copying your master key everywhere, encrypted with a password used infrequently. Either it will be too simple and easily crackable, or too complex and you will forget it. How can a friend or family access the key in case of emergency?</li>
<li>private information retrieval: PIR systems are databases that you can query for data, and the database will not know (in some margins) which piece of data you wanted. You do not need to go wild on homomorphic encryption to build something useful</li>
<li>encrypted search: the tradeoffs in search on encrypted data are well known, but there are not enough implementations</li>
<li>usable cryptography primitives: there is some work in that space, but people still rely on OpenSSL as their goto crypto library. Crypto primitives should not even let you make mistakes</li>
</ul>
<p>Those are worthwhile targets if you know a fair bit of cryptography and security, and know how to build a complete library or product.</p>
<p>But for products, we need better models for infrastructure needs. A like <a href="https://www.tahoe-lafs.org/trac/tahoe-lafs">Tahoe-LAFS</a> is a good model: the user is in control of the data, the provider is oblivious to the content, the user can be the client of multiple providers, and switching from one to another is easy. This does not make for shiny businesses. Infrastructure companies compete mainly on cost, scale, availability, speed, support, since they all provide roughly the same features.</p>
<p>Of course, infrastructure requires standards and interoperability, and this usually does not make good material for startup hype. But everyone wins from this in the end.</p>

    

    
      
      
      

      
    
  </article>
  

  
<div class="pagination">
  <a class="pagination-item older"
     href="/page3">
    Older
  </a>
</div>


</div>
    </main>

    <!-- Optional footer content -->

  </body>
</html>
