<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      How to rewrite your project in Rust &middot; Unhandled Expression
    
  </title>

  


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png" />
<link rel="shortcut icon" href="/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="post">

    <div id="sidebar">
  <header>
    <img src="https://s.gravatar.com/avatar/ed9901b9b80743c05aedf58b4f4926dd?s=200" alt="self" />
    <div class="site-title">
      <a href="/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        Unhandled Expression
      </a>
    </div>
    <p class="lead">Geoffroy Couprie â€“ software security and architecture consultant</p>
  </header>
  <nav id="sidebar-nav-links">
  
    <a class="home-link "
        href="/">Home</a>
  
  

  

  


  
    
  

  
    
      <a class="page-link "
          href="/about.html">About</a>
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  


  
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/architecture.html">Architecture</a>
    
  

  
    
      <a class="category-link "
          href="/category/crypto.html">Crypto</a>
    
  

  
    
      <a class="category-link "
          href="/category/development.html">Development</a>
    
  

  
    
  

  

  
    
      <a class="category-link "
          href="/category/rust.html">Rust</a>
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/security.html">Security</a>
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/videolan.html">VideoLAN</a>
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  <nav id="sidebar-icon-links">
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/tags.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  
    <a id="search-link"
       class="icon"
       title="Search" aria-label="Search"
       href="/search.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
    </a>
  

  <!-- Optional additional links to insert for icons links -->
</nav>
  <p>
  &copy; 2018.
  <a href="/LICENSE.md">MIT License.</a>
</p>

</div>


    <main class="container">
      <header>
  <h1 class="post-title">How to rewrite your project in Rust</h1>
</header>
<div class="content">
  <div class="post-meta">
  <span class="post-date">12 Jul 2017</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        General
      
    
      &bull;

      
      
      

      
        <a href="/category/rust.html">
          Rust
        </a>
      
    
  </span>
</div>

  <div class="post-body">
    <p>In a <a href="https://unhandledexpression.com/2017/07/10/why-you-should-actually-rewrite-it-in-rust/">previous post</a>, I explained why rewriting existing software in Rust could be a good idea. The main point being that you should not rewrite the whole application, but replace the weaker parts without disturbing most of the code, to strengthen the codebase without disruption.</p>
<p>I also provided pointers to projects where other people and I did it succesfully, but without giving too many details. So let's get a real introduction to Rust rewrites now. This article requires a little bit of knowledge about Rust, but you should be able to follow it even as a<br />
beginner.</p>
<p>As a reminder, here are the benefits Rust bring into a rewrite:</p>
<ul>
<li>it can easily call C code</li>
<li>it can easily be called by C code (it can export C compatible functions and structures)</li>
<li>it does not need a garbage collector</li>
<li>if you want, it does not even need to handle allocations</li>
<li>the Rust compiler can produce static and dynamic libraries, and even object files</li>
<li>the Rust compiler avoids most of the memory vulnerabilities you get in C (yes, I had to mention it)</li>
<li>Rust is easier to maintain than C (this is discutable, but not the point of this article)</li>
</ul>
<p>As it turns out, this is more or less the plan to replace C code with Rust:</p>
<ul>
<li>import C structures and functions in Rust</li>
<li>import Rust structures and functions from C</li>
<li>reuse the host application's memory allocations whenever possible</li>
<li>write code (yes, we have to do it at some point)</li>
<li>produce artefacts that can be linked with the host application</li>
<li>integrate with the build system</li>
</ul>
<p>We'll see how to apply this with examples from the Rust VLC plugin.</p>
<h2>Import C structures and functions in Rust</h2>
<p>Rust can easily use C code directly, by writing functions and structures definitions. A lot of the techniques you would use for this come from the <a href="https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html">"unsafe Rust" chapter</a> of "The Rust Programming Language" book. For the following C code:</p>
<p>[code lang=C]<br />
struct vlc_object_t {<br />
    const char   *object_type;<br />
    char         *header;<br />
    int           flags;<br />
    bool          force;<br />
    libvlc_int_t *libvlc;<br />
    vlc_object_t *parent;<br />
};<br />
[/code]</p>
<p>You would get the following Rust structure:</p>
<p>[code lang=C]<br />
extern crate libc;<br />
use libc::c_char;</p>
<p>#[repr(C)]<br />
pub struct vlc_object_t {<br />
  pub psz_object_type: *const c_char,<br />
  pub psz_header:      *mut c_char,<br />
  pub i_flags:         c_int,<br />
  pub b_force:         bool,<br />
  pub p_libvlc:        *mut libvlc_int_t,<br />
  pub p_parent:        *mut vlc_object_t,<br />
}<br />
[/code]</p>
<p>the <code>#[repr(C)]</code> tag indicates to the compiler that the structure should have a memory layout similar to the one generated by a C<br />
compiler. We import types from the libc crate, like <code>c_char</code>. Those types are platform dependent (with their different form already handled in libc). Here, we use a lot of raw pointers (indicated by <code>*</code>), which means by using this structure directly, we're basically writing C, which is no good! A good approach, as we'll see later, is to write safer wrappers above those C bindings.</p>
<p>Importing C functions is quite straightforward too:</p>
<p>[code lang=C]<br />
ssize_t  vlc_stream_Peek(stream_t *, const uint8_t **, size_t);<br />
ssize_t  vlc_stream_Read(stream_t *, void *buf, size_t len);<br />
uint64_t vlc_stream_Tell(const stream_t *);<br />
[/code]</p>
<p>These C function declarations would get translated to:</p>
<p>[code lang=C]<br />
#[link(name = &quot;vlccore&quot;)]<br />
extern {<br />
  pub fn vlc_stream_Peek(stream: *mut stream_t, buf: *mut *const uint8_t, size: size_t) -&gt; ssize_t;<br />
  pub fn vlc_stream_Read(stream: *mut stream_t, buf: *const c_void, size: size_t) -&gt; ssize_t;<br />
  pub fn vlc_stream_Tell(stream: *const stream_t) -&gt; uint64_t;<br />
}<br />
[/code]</p>
<p>The <code>#[link(name = "vlccore")]</code> tag indicates to which library we are linking. It is equivalent to passing a <code>-lvlccore</code> argument to the linker. Libvlccore is a library all VLC plugins must link to. Those functions are declared like regular Rust functions, but like the previous structures, will mainly work on raw pointers.</p>
<h3>bindgen</h3>
<p>You can always write all your bindings manually like this, but when the amount of code to import is a bit large, it can be a good idea to employ the awesome <a href="https://github.com/servo/rust-bindgen">bindgen</a> tool, that will generate Rust code from C headers.</p>
<p>It can work as a command line tool, but can also work at compile time from a <a href="http://doc.crates.io/build-script.html">build script</a>. First, add the dependency to your <code>Cargo.toml</code> file:</p>
<p>[code lang=toml]<br />
[build-dependencies.bindgen]<br />
version = &quot;^0.25&quot;<br />
[/code]</p>
<p>You can then write your build script like this:</p>
<p>[code lang=C]<br />
extern crate bindgen;<br />
use std::fs::File;<br />
use std::io::Write;<br />
use std::path::Path;</p>
<p>fn main() {<br />
  let include_arg = concat!(&quot;-I&quot;, env!(&quot;INCLUDE_DIR&quot;));<br />
  let vlc_common_path = concat!(env!(&quot;INCLUDE_DIR&quot;), &quot;/vlc_common.h&quot;);</p>
<p>  let _ = bindgen::builder()<br />
    .clang_arg(include_arg)<br />
    .clang_arg(&quot;-include&quot;)<br />
    .clang_arg(vlc_common_path)<br />
    .header(concat!(env!(&quot;INCLUDE_DIR&quot;), &quot;/vlc_block.h&quot;))<br />
    .hide_type(&quot;vlc_object_t&quot;)<br />
    .whitelist_recursively(true)<br />
    .whitelisted_type(&quot;block_t&quot;)<br />
    .whitelisted_function(&quot;block_Init&quot;)<br />
    .raw_line(&quot;use ffi::common::vlc_object_t;&quot;)<br />
    .use_core()<br />
    .generate().unwrap()<br />
    .write_to_file(&quot;src/ffi/block.rs&quot;);<br />
}<br />
[/code]</p>
<p>So there's a lot to unpack here, because bindgen is very flexible:</p>
<ul>
<li>we use <code>clang_arg</code> to pass the include folder path and pre include a header everywhere (<code>vlc_common.h</code> is included pretty puch everywhere in VLC)</li>
<li>the <code>header</code> method specifies the header from which we will import definitions</li>
<li><code>hide_type</code> prevents redefinition of elements we already defined (liek the ones from the common header)</li>
<li><code>whitelisted_type</code> and <code>whitelisted_function</code> specify types and functions for which bindgen will create definitions</li>
<li><code>raw_line</code> writes its argument at the top of the file. I apply it to reuse definitions from other files</li>
<li><code>write_to_file</code> writes the whole definition to the specified path</li>
</ul>
<p>You can apply that process to any C header you must import. With the build script, it can run every time the library is compiled, but be careful, generating a lot of headers can take some time. It might be a good idea to pregenerate them and commit the generated files, and update them from time to time.</p>
<p>It is usually a good idea to separate the imported definitions in another crate with the <code>-sys</code> suffix, and write the safe code in the main crate.<br />
As an example, see the crates <a href="https://crates.io/crates/openssl">openssl</a> and <a href="https://crates.io/crates/openssl-sys">openssl-sys</a>.</p>
<h3>Writing safe wrappers</h3>
<p>Previously, we imported the C function <code>ssize_t vlc_stream_Read(stream_t *, void *buf, size_t len)</code> as the Rust version <code>pub fn vlc_stream_Read(stream: *mut stream_t, buf: *const c_void, size: size_t) -&amp;gt; ssize_t</code> but kept an unsafe interface. Since we want to use those functions safely, we can now make a better wrapper:</p>
<p>[code lang=C]<br />
use ffi;</p>
<p>pub fn stream_Read(stream: *mut stream_t, buf: &amp;mut [u8]) -&gt; ssize_t {<br />
  unsafe {<br />
    ffi::vlc_stream_Read(stream, buf.as_mut_ptr() as *mut c_void, buf.len())<br />
  }<br />
}<br />
[/code]</p>
<p>Here we replaced the raw pointer to memory and the length with a mutable slice. We still use a raw pointer to the <code>stream_t</code> instance, maybe we can do better:</p>
<p>[code lang=C]<br />
use ffi;</p>
<p>pub struct Stream(*mut stream_t);</p>
<p>pub fn stream_Read(stream: Stream, buf: &amp;mut [u8]) -&gt; ssize_t {<br />
  unsafe {<br />
    ffi::vlc_stream_Read(stream.0, buf.as_mut_ptr() as *mut c_void, buf.len())<br />
  }<br />
}<br />
[/code]</p>
<p>Be careful if you plan to implement <a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>Drop</code></a> for this type: is the Rust code supposed to free that object? Is there some reference counting involved? Here is an example of <code>Drop</code> implementation from the openssl crate:</p>
<p>[code lang=C]<br />
pub struct SslContextBuilder(*mut ffi::SSL_CTX);</p>
<p>impl Drop for SslContextBuilder {<br />
    fn drop(&amp;mut self) {<br />
        unsafe { ffi::SSL_CTX_free(self.as_ptr()) }<br />
    }<br />
}<br />
[/code]</p>
<p>Remember that it's likely the host application has a lot of infrastructure to keep track of memory, and as a rule, we should reuse the tools it offers for the code at the interface between Rust and C. See the <a href="http://jakegoulding.com/rust-ffi-omnibus/">Rust FFI omnibus</a> for more examples of safe wrappers you can write.</p>
<p><em>Side note: as of now (2017/07/10) <a href="https://github.com/rust-lang/rust/issues/32838">custom allocators</a> are still not stable</em></p>
<h2>Exporting Rust code to be called from C</h2>
<p>Since the host application is written in C, it might need to call your code. This is quite easy in Rust: you need to write unsafe wrappers.</p>
<p>Here we will use as example the <a href="https://github.com/Geal/rust-devoxx2016">inverted index library for mobile apps</a> I wrote for a conference. In this library, we have an <code>Index</code> type that we want to use from Java. Here is its definition:</p>
<p>[code lang=C]<br />
#[repr(C)]<br />
pub struct Index {<br />
  pub index: HashMap&lt;String, HashSet&lt;i32&gt;&gt;,<br />
}<br />
[/code]</p>
<p>This type has a few method we want to provide:</p>
<p>[code lang=C]<br />
impl Index {<br />
  pub fn new() -&gt; Index {<br />
    Index {<br />
      index: HashMap::new(),<br />
    }<br />
  }</p>
<p>  pub fn insert(&amp;mut self, id: i32, data: &amp;str) {<br />
    [...]<br />
  }</p>
<p>  pub fn search_word(&amp;self, word: &amp;str) -&gt; Option&lt;&amp;HashSet&lt;i32&gt;&gt; {<br />
    self.index.get(word)<br />
  }</p>
<p>  pub fn search(&amp;self, text: &amp;str) -&gt; HashSet&lt;i32&gt; {<br />
    [...]<br />
  }<br />
}<br />
[/code]</p>
<p>First, we need to write the functions to allocate and deallocate our index. Every use from C will be wrapped in a <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>.</p>
<p>[code lang=C]<br />
#[no_mangle]<br />
pub extern &quot;C&quot; fn index_create() -&gt; *mut Index {<br />
  Box::into_raw(Box::new(Index::new()))<br />
}<br />
[/code]</p>
<p>The <code>Box</code> type indicates and owns a heap allocation. When the box is dropped, the underlying data is dropped as well and the memory is freed. The following function takes ownership of its argument, so it is dropped at the end.</p>
<p>[code lang=C]<br />
#[no_mangle]<br />
pub extern &quot;C&quot; fn index_free(ptr: *mut Index) {<br />
    let _ = unsafe { Box::from_raw(ptr) };<br />
}<br />
[/code]</p>
<p>Now that allocation is handled, we can work on a real method. The following method takes an index, and id for a text, and the text itself, as a C string (ie, terminated by a null character).</p>
<p>Since we're kinda writing C in Rust here, we have to first check if the pointers are null. Then we can transform the C string in a slice. Then we check if it is correctly encoded as UTF-8 before inserting it into our index.</p>
<p>[code lang=C]<br />
#[no_mangle]<br />
pub extern &quot;C&quot; fn index_insert(index: *mut Index, id: i32, raw_text: *const c_char) {<br />
  unsafe { if index.is_null() || raw_text.is_null() { return } };<br />
  let slice = unsafe { CStr::from_ptr(raw_text).to_bytes() };<br />
  if let Ok(text) = str::from_utf8(slice) {<br />
    (*index).insert(id, text);<br />
  }<br />
}<br />
[/code]</p>
<p>Most of the code for those kinds of wrappers is just there to transform between C and Rust types and checking that the arguments coming from C code are correct. Even if we have to trust the host application, we should program defensively at the boundary.</p>
<p>There are <a href="https://github.com/Geal/rust-devoxx2016/blob/master/inverted_index/src/lib.rs#L96-L121">other methods we could implement</a> for the index, we'll leave those as exercise for the reader :)</p>
<p>Now, we need to write the C definitions to import those functions and types:</p>
<p>[code lang=C]<br />
typedef struct Index Index;</p>
<p>Index* index_create();<br />
void   index_free(Index* index);<br />
void   index_insert(Index* index, int32_t id, char const* raw_text);<br />
[/code]</p>
<p>We defined <code>Index</code> as an opaque type here. Since Rust structures can be compatible with C structures, we could export the real type, but since it only contains a Rust specific type, <code>HashMap</code>, it is better to hide it completely and write accessors and wrappers.</p>
<h3>Generating bindings with rusty-cheddar</h3>
<p>Writing function imports from C to Rust is tedious, so we have bindgen for this. We also have a great tool to go the other way: <a href="https://github.com/Sean1708/rusty-cheddar">rusty-cheddar</a>.</p>
<p>In the same way, it can be used from a build script:</p>
<p>[code lang=C]<br />
extern crate cheddar;</p>
<p>fn main() {<br />
  cheddar::Cheddar::new().expect(&quot;could not read definitions&quot;)<br />
    .run_build(&quot;include/main.h&quot;);<br />
  cheddar::Cheddar::new().expect(&quot;could not read definitions&quot;)<br />
    .module(&quot;index&quot;).expect(&quot;malformed module path&quot;)<br />
    .insert_code(&quot;#include \&quot;main.h\&quot;&quot;)<br />
    .run_build(&quot;include/index.h&quot;);<br />
}<br />
[/code]</p>
<p>Here we run rusty-cheddar a first time without specifying the module: it will default to generate a header for the definitions in <code>src/lib.rs</code>.<br />
The second run specifies a different module, and can insert a file inclusion at the top.</p>
<p>It can be a good idea to commit the generated headers, since you will see immediately if you changed the interface in a breaking way.</p>
<h2>Integrating with the build system</h2>
<p>As you might know, we can make dynamic libraries and executables with rustc and cargo. But often, the host application will have its own build system, and it might disagree with the way cargo builds its projects. So we have multiple strategies:</p>
<ul>
<li>build Rust code separately, store libraries and headers in Maven or something (don't laugh, I've worked with such a system once, and it was actually great)</li>
<li>try to let rustc build dynamic libraries from inside the build system. We tried that for VLC and it was not great at all</li>
<li>build a static library from inside or outside the build system, include it in the libraries at link. This was done in <a href="https://github.com/rusticata/rusticata">Rusticata</a></li>
<li>build an object file and let the build system link it. This is what we ended up doing with VLC</li>
</ul>
<p>Building a static library is as easy as specifying <code>crate-type = ["staticlib"]</code> in your <code>Cargo.toml</code> file. To build an object file, use the command <code>cargo rustc --release -- --emit obj</code>. You can see how we added it to the <a href="https://github.com/Geal/vlc/blob/rust/modules/demux/Makefile.am#L464-L477">autotools usage in VLC</a>.</p>
<p>Unfortunately, for this part we still do not have automated ways to fix the issues. Maybe with some time, people will write scripts for autotools,<br />
CMake and others to handle Rust and Cargo.</p>
<p><em>Side note on reproducible builds: if you want to fix the set of Rust dependencies used in your project and make them always available, you can use <a href="https://github.com/alexcrichton/cargo-vendor">cargo-vendor</a> to store them in a specific folder</em></p>
<p>As you might have guessed, this is the most complex part, for which I have no good generic answer. I'd recommend that you spend the most time on this during the project's prototyping phase: import very little C code, export very little Rust code, try to make it build entirely from within the host application's build system. Once this is done, extending the project will get much easier. You really don't want to discover this task at the end of your project and try to retrofit your code in there.</p>
<h2>Going further</h2>
<p>While this article just explores the surface of Rust rewrites, I hope it provides a good starting point on the tools and techniques you can apply.<br />
Any rewrite will be a large and complex project, but the result is worth the effort. The code you will write will be stronger, and Rust's type system will force you to review the assumptions made in the C version. You might even find better ways to write it once you start refactoring your code in a more Rusty way, safely hidden behind your wrappers.</p>

    



<div class="post-tags">
  
    
    <a href="/tags.html#security">
    
      <span class="icon">
        <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
      </span>&nbsp;<span class="tag-name">security</span>
    </a>
  
</div>
  </div>

  
<!--  <section class="comments">
    <h2>Comments</h2>
  </section>
-->


  <section class="related">
  <h2>Related Posts</h2>
  <ul class="posts-list">
    
      <li>
        <h3>
          <a href="/general/rust/2018/02/02/poc-compiling-to-ebpf-from-rust.html">
            PoC: compiling to eBPF from Rust
            <small>02 Feb 2018</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/rust/2018/01/10/rust-2018-maybe-dont-be-too-stable.html">
            Rust 2018: maybe don't be too stable
            <small>10 Jan 2018</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/general/2017/08/23/adventures-in-logging.html">
            Adventures in logging
            <small>23 Aug 2017</small>
          </a>
        </h3>
      </li>
    
  </ul>
</section>

</div>

    </main>

    <!-- Optional footer content -->

  </body>
</html>
