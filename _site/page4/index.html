<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Unhandled Expression &middot; Geoffroy Couprie – software security and architecture consultant
    
  </title>

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-117988815-1', 'auto');
  ga('send', 'pageview');
  </script>



  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png" />
<link rel="shortcut icon" href="/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="index">

    <div id="sidebar">
  <header>
    <img src="https://s.gravatar.com/avatar/ed9901b9b80743c05aedf58b4f4926dd?s=200" alt="self" />
    <h1 class="site-title">
      <a href="/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        Unhandled Expression
      </a>
    </h1>
    <p class="lead">Geoffroy Couprie – software security and architecture consultant</p>
  </header>
  <nav id="sidebar-nav-links">
  
    <a class="home-link "
        href="/">Home</a>
  
  

  

  


  
    
  

  
    
      <a class="page-link "
          href="/about.html">About</a>
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  


  
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/architecture.html">Architecture</a>
    
  

  
    
      <a class="category-link "
          href="/category/crypto.html">Crypto</a>
    
  

  
    
      <a class="category-link "
          href="/category/development.html">Development</a>
    
  

  
    
  

  

  
    
      <a class="category-link "
          href="/category/rust.html">Rust</a>
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/security.html">Security</a>
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/videolan.html">VideoLAN</a>
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  <nav id="sidebar-icon-links">
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/tags.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  
    <a id="search-link"
       class="icon"
       title="Search" aria-label="Search"
       href="/search.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
    </a>
  

  <!-- Optional additional links to insert for icons links -->
</nav>
  <a class="category-link active" href="https://www.patreon.com/geoffroy">Support my work on Patreon</a>
  <!--<p>
  &copy; 2018.
  <a href="/LICENSE.md">MIT License.</a>
</p>
-->
</div>


    <main class="container">
      <div class="content">
  
<div class="pagination">
  <a class="pagination-item newer"
     href="/page3">
    Newer
  </a>
</div>



  

  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/crypto/protocols/2014/04/07/revisiting-zookos-triangle.html">
        Revisiting Zooko's triangle
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">07 Apr 2014</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/crypto.html">
          Crypto
        </a>
      
    
      &bull;

      
      
      

      
        Protocols
      
    
  </span>
</div>

    
      <p>In 2001, <a title=" *introduction | *current events | *stuff Names: Distributed, Secure, Human-Readable: Choose Two" href="http://web.archive.org/web/20011020191610/http://zooko.com/distnames.html" target="_blank">Zooko Wilcox-O'Hearn conjectured</a> that a key value system, in the way the keys address those values, must make a compromise between three properties. Those properties are:</p>
<ul>
<li>distributed: there is no central authority in the system (and the other nodes of the system are potentially untrusted)</li>
<li>secure: a name lookup cannot return an incorrect value, even in the presence of an attacker</li>
<li>human usable keys: keys that a human will be able to remember and write without errors</li>
</ul>
<p>The conjecture stated that you may have at most two out of these three properties in the system.</p>
<p>Examples of those properties at work:</p>
<ul>
<li>the DNS is secure (one possible record for a given name) and human usable (domain names can be learned), but not distributed (the server chain is centralized)</li>
<li>the PGP mapping between email and public keys is distributed (no central authority defining which email has which key) and human usable (public keys are indexed by emails) but not secure (depending on your view of the web of trust, identities could be falsified)</li>
<li>Tor .onion addresses are secure (the address is the hash of the public key) and distributed (nobody can decide that an address redirects to the wrong server) but not human meaningful (have you seen those addresses?)</li>
</ul>
<p>Some systems, like NameCoin, emerged lately and exhibited those three properties at the same time. So is the conjecture disproved? Not really.</p>
<p>When considering that triangle, people often make a mistake: assuming that you have to choose two of these properties and will never approach the third. These properties must not be seen as absolute.</p>
<p>Human usability is easily addressed with Petname systems, where a software assistant can help you add human-meaningful names to secure and distributed keys (at risk of collision, but not system wide).</p>
<p>You can add some distributed features in a centralized system like SSL certificate authorities by accepting multiple authorities.</p>
<p>NameCoin is distributed and human meaningful, and creates a secure view of the system through the blockchain.</p>
<p>And so on.</p>
<p>The three properties should be redefined with what we know ten years later.</p>
<h2>Human usable names</h2>
<p>We now understand that a human meaningful name is a complex concept. We see people typing "facebook" in a search engine because they would not remember "facebook.com". Phone numbers are difficult to remember. Passwords, even when chosen through easy to remember methods, will be repeated at some point. And we could also talk about typosquatting...</p>
<p>Here is a proposition: <strong>a human usable key is an identifier that a human can remember easily in large numbers and distinguish as easily from other identifiers</strong>. I say identifier because it could be a string, a picture, anything that stands out enough to be remember and for which differences could be easily spotted.</p>
<p>That definition is useful because it is quantifiable. We can measure how many 10 digits phone numbers a human can remember. We can measure how many differences a human can spot in two strings or pictures.</p>
<h2>Decentralized and/or secure names</h2>
<p>The original text indicates distributed as "there is no central authority which can control the namespace, which is the same as saying that the namespace spans trust boundaries". The trust boundary is defined as the space in which nodes could be vulnerable to each other (because they trust each other). In a fully distributed system, a node may not be able to force any other node to have a different view of the system.</p>
<p>Secure means that there is only one correct answer for a name lookup, whoever does the lookup. This is the same as saying that there is a consensus (at least in a distributed system).</p>
<p>We can see that the decentralized and secure properties are at odds with the consensus problem in a distributed system. This is where systems like NameCoin make the compromise. They exchange an absolute secure view of the system for an eventual consistency, and fully distributed trust boundaries for byzantine problems. They guarantee that, at some point, and unless there are too many traitors in the systems, there will be a universal and unique mapping for a human readable name.</p>
<p>So, we could replace the "secure" property by: <strong>the whole system recognizes that there is only one good answer for a record at some point in the future</strong>. Again, this is measurable, and it also addresses the oddity in DNS that records have to propagate (so sometimes the view can differ). Systems where identifiers do not give unique responses will not satisfy that definition.</p>
<p>The last property, "decentralized", can be formulated like this: <strong>a node's view of the names cannot be influenced by a group of unauthorized nodes</strong>. In a centralized system, where there is essentially one node, this definition cannot apply. In a hierarchy of nodes, like DNS, we can easily see that a node's view can be abused, since there is only one node you need to compromise to influence it, its first nameserver (this is used, for good and for bad reasons, in a lot of companies). In a distributed system, this definition becomes quantifiable and joins the byzantine problem: how many traitor nodes do you need to modify a node's view of the system?</p>
<p>Here, we have three new definitions that are more nuanced, allow some compromise and modulation of the needs, and for which the limits can be measured or calculated. These quantified limits can be useful to describe and compare the future naming system propositions.</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/crypto/general/security/2014/02/21/how-to-choose-your-secure-messaging-app.html">
        How to choose your secure messaging app
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">21 Feb 2014</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/crypto.html">
          Crypto
        </a>
      
    
      &bull;

      
      
      

      
        General
      
    
      &bull;

      
      
      

      
        <a href="/category/security.html">
          Security
        </a>
      
    
  </span>
</div>

    
      <p>Since WhatsApp announced its acquisition, a lot of people started to switch to alternatives, trying to escape from Facebook. Some of them then discovered <a href="http://unhandledexpression.com/2013/12/17/telegram-stand-back-we-know-maths/" target="_blank">my article about Telegram</a>, and a common answer was "hey, at least, it is better than WhatsApp, because it is open source, faster and it has encryption".</p>
<p>This is a very bad way to decide what application you should use. If you choose a secure messaging app, it must be because you need it, not just because you want to avoid Facebook.</p>
<p>Those are <strong>not</strong> good enough requirements:</p>
<ul>
<li>independent from Facebook</li>
<li>fast</li>
<li>multi platforms</li>
<li>open source</li>
</ul>
<p>Yes, even open source, because it does not magically make software safe.</p>
<p>So, what are goods requirements? Well, I already have a<a href="http://unhandledexpression.com/2013/12/20/criterions-for-a-crypto-app/" target="_blank"> list of what a secure messaging app should meet</a> to be considered. If an app does not follow those requirements, it may not be a good idea to use it.</p>
<p>But it still does not mean the app will fit your use case. So you must define your use case:</p>
<ul>
<li>Why do you need it?</li>
<li>With whom will you communicate?</li>
<li>Who is the adversary?</li>
<li>What will happen if some of your information is revealed to the adversary?</li>
<li>Does it need to be always available?</li>
<li>For how long will it be used?</li>
</ul>
<p>This is part of what I mean when I insist on having a threat model: you cannot choose correctly if you do not know the risks.</p>
<p>Here are a few examples that you could consider.</p>
<h3>The activist in a protest</h3>
<p>The activist must be able to communicate quickly in the crowd. Identifying info might not be the most important part, because she can use burner phones (phones that will be abandoned after the protest). The most important feature is that it should be always available. Phone networks were often used to disrupt activist communication, so a way to send message through WiFi our bluetooth might be useful. The messages can be sent to a lot of different people, so being able to identify them might be important. If it is large enough to be infiltrated easily, then having no way to identify people is crucial.</p>
<p>Being able to send photos is important, because they might be the only proof of what happened in the protest. Here, I have in mind the excellent ObscuraCam app, which is able to quickly hide the faces of people in photos before sending them.</p>
<p>The application should not keep logs, or provide a way to quickly delete them, or encrypt them by default, because once someone is caught, the police will look through the phone.</p>
<p>The crypto algorithms and protocols should be safe and proven for that use case, because the adversaries will have the resources to exploit any flaw.</p>
<p>No need for a good update system if the devices will be destroyed after use.</p>
<h3>The employee of a company with confidential projects</h3>
<p>The adversaries here are other companies, or even other countries. The most important practice here is the "need to know": reduce the number of persons knowing the confidential information. that means the persons communicating between themselves is reduced, and you can expect that they have a mean of exchanging information securely (example: to verify a public key).</p>
<p>Identifying who talks with whom is not really dangerous, because it is easy to track the different groups in a company. You may be confident enough that the reduced group will not be infiltrated by the adversary. The messages should be stored, and ideally be searchable. File exchange should be present.</p>
<p>There could be some kind of escrow system, to reveal information if you have a certain access level. Authentication is a crucial point.</p>
<p>The crypto may be funnier for that case, because the flexibility needed can be provided by some systems, like identity based encryption.Enterprise policies might be able to force regular uodates of the system, so that everybody has the same protocol version at the ame time, and any eventual flaw will be patched quickly.</p>
<h3>The common user</h3>
<p>It is you, me, anyone wanting to exchange private messages with friends or family. Here, trying to protect against the NSA is futile, because most of the contacts might not have the training needed. Trying to hide the contacts list from Facebook is futile too: even if someone protects the information, one of the contacts may not. The adversary you should consider here: crooks, pirates, anyone that could exploit the private messages for criminal ways (stealing bank info, blakcmailing, sending malware, etc).</p>
<p>An application fitting this use case should encrypt messages, preferably end to end, to limit problems when the exchange server is compromised. The service might not provide any expectation of anonymity. Messages should be stored, but encrypting them is a good option, in case the device is lost or stolen.</p>
<p>The crypto does not need to be very advanced, but it should use common, well known designs.</p>
<p>There should be a good update system, a way to negotiate protocol versions (and forbid some unsafe versions), because you will never be sure that everybody has performed all the needed updates.</p>
<h3>Your use case here</h3>
<p>Those were some common situations, for which some solutions exist, but there are a lot more possible use cases. If you are not sure about yours and need help defining your threat model, do not hesitate to ask for help, and do not jump on a solution because the marketing material says it is safe.</p>
<p>A good security solution will not only tell you what is protected, and how, but also what is not protected, and the security margins you have. It will also teach you the discipline you need to apply to get the most out of it.</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/general/2014/02/20/problem-with-meritocracy.html">
        The problem with meritocracy
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">20 Feb 2014</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        General
      
    
  </span>
</div>

    
      <p>Everytime people discuss the hacker community and its diversity, I see someone waving the "meritocracy" argument. "It is not our fault those minorities are not well represented, if they knew more stuff or did more stuff, they would have a better status".</p>
<p>It is easy to see how that argument would be flawed, as meritocracy is a power structure, and whenever a power structure is created, after some time it tends to reinforce its own community. But that is not my point right now.</p>
<p>I realized that the idea of meritocracy is so deeply ingrained in the hacker mindset that we lost sight of what was important. I can see how that idea is appealing. Once you prove you know stuff, people will recognize you, and that will be enough to motivate you to learn. Except it is not. The meritocracy is just another way to exclude people. Once you consider someone's status by how much you perceive they know, things go downhill.</p>
<p>Some are good at faking knowledge. Some know their craft, but do not talk that well. Some are not experts, but have good ideas. Some would like to learn without being judged. Everytime you dismiss someone's opinion because of their apparent (lack of) knowledge, everytime you favor someone's opinion because of their apparent knowledge, you are being unscientific and unwelcoming. You are not a hacker, you are just a jerk.</p>
<p><strong>Somewhere along the way, people got too hung up on meritocracy, and forgot that you hack for knowledge and for fun, not for status</strong>. It is all about testing stuff, learning, sharing what you learned, discussing ideas and helping others do the same, whatever their skills or their experience. Status and power structures should have nothing to do with that.</p>
<p>Guess what? I pointed out that bad behaviour, but I am guilty of it too. I have to constantly keep myself in check, to avoid judging people instead of judging ideas. That's alright. Doing the right thing always requires some effort.</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/crypto/security/2013/12/20/criterions-for-a-crypto-app.html">
        Criterions for a crypto app
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">20 Dec 2013</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/crypto.html">
          Crypto
        </a>
      
    
      &bull;

      
      
      

      
        <a href="/category/security.html">
          Security
        </a>
      
    
  </span>
</div>

    
      <p>Following the previous article, people have asked me what I would consider as a good secure system, and others asked me to review their app, so I think it will be interesting to expose my process when studying those projects.</p>
<h2>Threat modeling</h2>
<p>The most important point I look for in a project is <strong>the threat model</strong>. This is the document that will explain for whom the project was created, who are the adversaries, what they are trying to obtain, and which of these threats you are addressing.</p>
<p>Without that document, I cannot know if you considered all the possible actors, and I must infer it from the protocol, which is relatively easy, but my view of the threat model might not correspond to what you expected.</p>
<p>With a good threat model, I can know right away what is your target market (ex: sexting for teens, or secure reporting for journalists in war environments), see if your users will understand the implications, if it will need training, and more importantly, if your system can be safe for that context.</p>
<p><strong>You cannot create a project and say that it will solve all of the privacy problems with some magical crypto algorithm</strong>, against all adversaries, even the state actors. I would prefer a useful tool for a niche with real and well defined needs.</p>
<h2>Prior art</h2>
<p>As you have probably seen, the secure messaging space is already very crowded. If you come up with a new solution to an already solved problem, you need to justify it. Why didn't you improve an existing project? Couldn't you adapt someone else's code, add a better UI?</p>
<p>the NIH syndrome is at the heart of innovation, so I am not against it. But in the case of crypto applications, it might be a good idea to employ already existing (and already audited) code, instead of writing a whole new protocol or algorithm from scratch.</p>
<p>Otherwise, <strong>if you are working on an unsolved problem, or improving on current solutions, be prepared to justify it</strong>, and a lot, if you employ unusual systems. I am not telling you to avoid funny stuff like Pailler's cryptosystem, PIR or pairing based cryptography. Just be aware that people will ask you about these.</p>
<h2>Publications</h2>
<p>That part is fundamental: <strong>if you are providing a new protocol or algorithm, you should publish it and ask for review before you start coding and get users</strong>. I am not advising you to start up LaTeX and write a paper in ACM format. Just explaining your system on a webpage is fine. The crypto community is full of nice people that will be able to point out if there is any problem (and if you use the academic way of publishing, you might even profit from other people's funding to get reviews :p).</p>
<p>Some said that the crypto community is full of bitter people eager to hit any new project, following the whole Telegram debacle. That tends to happen when you make a big announcement to get users, telling that it will solve any security problem, and dismiss the opinions of experts, without having asked for review previously.</p>
<p>Note that some of those experts have worked for years on a project before even thinking of communicating about it. As examples, check out <a title="Briar" href="http://briar.sourceforge.net/" target="_blank">Briar</a>, <a title="Pond" href="https://pond.imperialviolet.org/" target="_blank">Pond</a> or <a title="Cryptosphere" href="http://cryptosphere.org/" target="_blank">Cryptosphere</a>: those are quiet but interesting projects. They are not trying to get a lot of users quickly or profit from the post Snowden panic. They have been at it for a long time.</p>
<p>So, publish, ask for review, fix flaws, publish again, fix stuff, and repeat again and again. That is the smartest way to spend your time and money on your project. Once everything is developed and deployed, you will have a hard time trying to plug the holes.</p>
<h2>Protocol design</h2>
<p>Once we get in the technical stuff, the protocol design is interesting to get a high level view of what you want to achieve. I'll ask questions like:</p>
<ul>
<li>Is it server centric or P2P? (note: a network of server introduces routing, but is not P2P)</li>
<li>Does it include authentication?</li>
<li>Is it encrypted end to end?</li>
<li>How do you protect against DoS?</li>
<li>Is it versioned? Do you allow for protocol version negotiation? Are the algorithms negotiated?</li>
<li>Can you revoke keys or identities?</li>
</ul>
<p>Often, <strong>the protocol show what you want to achieve with your system, and it is often answering more threats than the crypto algorithms themselves</strong>. A good way to present your protocols is to use <a title="XKCD style sequence diagrams" href="http://bramp.github.io/js-sequence-diagrams/" target="_blank">diagrams</a> and present the message contents.</p>
<p>Do not insist on algorithms at this point: use general words to describe the primitive you need, like authenticated cipher, public key, key derivation function, MAC. You might change the algorithms later, so stating the properties you need will help reviewers understand what you want to achieve.</p>
<p>A specific note on server VS peer to peer: it is a very understandable feeling for geeks that P2P architectures look better, because they're decentralizing everything, etc. But they can introduce other problems (like hole punching or sybil attacks), and in some case, you will not be able to avoid servers (for message routing and retries, for mobile systems, etc). Both types of systems are fine, just be aware of their shortcomings.</p>
<h2>Cryptographic constructs</h2>
<p>Cryptographic algorithms are not enough, you need to apply them correctly.<strong> I will have no pity if you say you use "military grade AES 256 encryption"</strong> but do not know what is a <a title="ECB is when you see the penguin" href="http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" target="_blank">block cipher mode</a> or <a title="Encrypt-Then-MAC" href="http://www.daemonology.net/blog/2009-06-24-encrypt-then-mac.html" target="_blank">Encrypt-Then-MAC</a>. A lot of ugly details can hide here, so do not try to be clever, use battle tested systems:</p>
<ul>
<li>add a separate authentication layer to Diffie-Hellman key exchanges</li>
<li>use an authenticated encryption mode</li>
<li>use RSA-OAEP instead of PKCS1 padding</li>
<li>know well if you need a nonce, an unpredictable number or a time based ID</li>
<li>etc.</li>
</ul>
<p>This is one of the parts where crypto experts will ask annoying questions, because a lot of bugs come from there. They can also propose better solutions (safer, more performant, etc), so listen to them.</p>
<p>If you are employing an unusual scheme here, be prepared to justify it. It might be ok for you, but if the design looks weird to cryptographers, that will raise alarms. Your scheme could be safe, but if it has never been proven right, you are taking a risk, and your users will take that risk too. Is it worth it? Hint: your weird design should provide a unique property that no other algorithm has.</p>
<h2>Choice of algorithms</h2>
<p>Yes, I do not worry about algorithms until I am already deep in the system. It is not that hard to make correct choices there. Just listen to the recent attacks (ie, avoid RC4) choose large enough keys, choose correct elliptic curves.</p>
<p>Every algorithm has parameters that you need to get right, so be sure to document yourself on your algorithm choices:</p>
<ul>
<li>AES-CBC needs an initialization vector, but AES-CTR uses an incremented nonce</li>
<li>RSA needs a good exponent</li>
<li>Some elliptic curves <a href="http://en.wikipedia.org/wiki/Table_of_costs_of_operations_in_elliptic_curves" target="_blank">work better for some operations</a></li>
</ul>
<p>Even if you choose dubious algorithms, if your protocol was well designed, you will be able to move to better algorithm. Be careful with algorithm negotiation, though, a lot of smart people were bitten before.</p>
<h2>The implementation</h2>
<p>This is probably the part that I will skip, because I do not have the time nor the funding to audit thoroughly the code of every new projects. I will often grep a bit through the code, look for some important points, but this is not something that should be done quickly. This is where the protocol review shows its limits.</p>
<p><strong>Even with a good design, a lot of vulnerabilities can be present in a flawed implementation</strong>. Crypto projects should undergo a careful audit like the one <a title="Least Authority" href="https://leastauthority.com/" target="_blank">Least Authority</a> performed recently on <a title="Cryptocat" href="https://crypto.cat/" target="_blank">Cryptocat</a>. And that is why you should not communicate about your project before it has been reviewed.</p>
<p>There are things you should always look for in your software projects:</p>
<ul>
<li>encrypting data at rest: if you worry about stolen data, know that a mobile phone or laptop can be stolen</li>
<li>random number generation: you should use a CSPRNG, with a good source, and probably some user or device specific data</li>
<li>data backup: is it possible? is it safe?</li>
<li>software updates: are they downloaded from a secure source? Are the updates verified?</li>
<li>Do you use public key pinning?</li>
<li>How long are they private keys stored as plaintext in memory?</li>
</ul>
<p>The implementation details are as important as the whole protocol. You can have a good protocol, but a small error in the code could greatly affect your users. Nevertheless, specifying your protocol is useful, because people can provide better implementations, or make it interoperate with other software. Having other implementations is a good thing: you will not control those versions, but they will be able to construct cool stuff around your system, and make a part of your PR.</p>
<h2>User interface</h2>
<p>this part is more and more important, because we have been able to create safe systems for years, but often at the price of usability. The user experience of crypto apps needs a lot of innovation, and I'll follow closely any interesting idea in that space: onboarding experience, useful alerts, user decision making, etc. People should be able to understand when there is a security problem.</p>
<p>I'll state it once more: <strong>if you create a new crypto software, you HAVE to make it easy to use and understand</strong>. Some complexity is acceptable, but it must be compensated by documentation (with screenshots, etc) or training.</p>
<h2>Other criterions</h2>
<p>There are two others that I could think of, but they do not matter that much.</p>
<p>The first is the team. I have been accused of making fun of Telegram for waving around their team of PhDs, but the truth is that I was hopeful: a team full of smart people can come up with interesting design and solve complex problems. If they do not deliver on that, I could be less indulgent. That does not mean I will think less of people without big diplomas. I know too many smart people that dropped out of school to make that mistake. Ultimately, the important thing to judge is the design.</p>
<p>The last parameter is attitude. It is normal to be defensive when someone else reviews your work, but that does not justify denial and dishonesty. People are often taking time off of their job to study your system, so they will be quick and get to the point. If you do not answer or refuse to explain your decisions, it will smell fishy. Even more if you did not ask for a review before communicating about your project. But it does not matter that much. If you are humble and quick to answer, people may help you out of good will, but if you anger cryptographers, you may just have won a free thorough audit :D</p>
<p>&nbsp;</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/crypto/general/security/2013/12/17/telegram-stand-back-we-know-maths.html">
        Telegram, AKA "Stand back, we have Math PhDs!"
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">17 Dec 2013</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/crypto.html">
          Crypto
        </a>
      
    
      &bull;

      
      
      

      
        General
      
    
      &bull;

      
      
      

      
        <a href="/category/security.html">
          Security
        </a>
      
    
  </span>
</div>

    
      <p><strong>Disclaimer: this post is now very old and may not reflect the current state of Telegram's protocol. There has been other research in the meantime, and this post should not be used for your choice of secure messaging app. That said, on a personal note, I still think Telegram's cryptosystem is weird, and its justifications are fallacious. If you want a recommendation on secure messaging apps: use a system based on the <a href="https://whispersystems.org/blog/signal-inside-and-out/" target="_blank">Axolotl/Signal</a> protocol. It is well designed and has been audited. <a href="https://whispersystems.org/" target="_blank">Signal</a> and <a href="https://www.whatsapp.com/security/" target="_blank">WhatsApp</a> are both using that protocol, and there are others.</strong></p>
<p>Here is the second entry in our serie about weird encryption apps, about <a title="Telegram" href="http://telegram.org" target="_blank">Telegram</a>, which got some press recently.</p>
<p>According to their website, Telegram is "cloud based and heavily encrypted". How secure is it?</p>
<blockquote><p>Very secure. We are based on a new protocol, MTProto, built by our own specialists, employing time-tested security algorithms. At this moment, the biggest security threat to your Telegram messages is your mother reading over your shoulder. We took care of the rest.</p></blockquote>
<p>(from their <a title="Telegram's FAQ" href="http://telegram.org/faq#security" target="_blank">FAQ</a>)</p>
<p>Yup. Very secure, they said it.</p>
<p>So, let's take a look around.</p>
<h2>Available technical information</h2>
<p>Their website details the protocol. They could have added some diagrams, instead of text-only, but that's still readable. There is also <a title="Open source Telegram protocol" href="https://github.com/ex3ndr/telegram-mt/" target="_blank">an open source Java implementation of their protocol</a>. That's a good point.</p>
<p>About the team (yes, I know, I said I would not do ad hominem attacks, but they insist on that point):</p>
<blockquote><p><span style="color:#000000;">The team behind Telegram, led by Nikolai Durov, consists of six ACM champions, half of them Ph.Ds in math. It took them about two years to roll out the current version of MTProto. Names and degrees may indeed not mean as much in some fields as they do in others, but this protocol is the result of thougtful and prolonged work of professionals</span></p></blockquote>
<p>(Seen on <a title="Telegram on Hacker News" href="https://news.ycombinator.com/item?id=6916860" target="_blank">Hacker News</a>)</p>
<p>They are not cryptographers, but they have some background in maths. Great!</p>
<p>So, what is the system's architecture? <strong>Basically, a few servers everywhere in the world, routing messages between clients</strong>. Authentication is only done between the client and the server, not between clients communicating with each other. Encryption happens between the client and the server, but not using TLS (some home made protocol instead). Encryption can happen <a title="Telegram's secret chats" href="https://core.telegram.org/api/end-to-end" target="_blank">end to end</a> between clients, but there is no authentication, so <strong>the server can perform a MITM attack</strong>.</p>
<p>Basically, their threat model is a simple "trust the server". What goes around the network may be safely encrypted, although we don't know anything about their server to server communication, nor about their data storage system. But whatever goes through the server is available in clear. By today's standards, that's boring, unsafe and careless. For equivalent systems, see Lavabit or iMessage. <strong>They will not protect your messages against law enforcement eavesdropping or server compromise. Worse: you cannot detect MITM between you and your peers</strong>.</p>
<p>I could stop there, but that would not be fun. The juicy bits are in the crypto design. The ideas are not wrong per se, but the algorithm choices are weird and unsafe, and they take the most complicated route for everything.</p>
<h2>Network protocol</h2>
<p>The protocol has two phases: the key exchange and the communication.</p>
<p>The key exchange registers a device to the server. They wrote a custom protocol for that, because TLS was too slow and complicated. That's true, TLS needs two roundtrips between the client and the server to exchange a key. It also needs x509 certificates, and a combination of a public key algorithm like RSA or DSA, and eventually a key exchange algorithm like Diffie-Hellman.</p>
<p><a title="Telegram's key exchange" href="http://core.telegram.org/mtproto/auth_key" target="_blank">Telegram greatly simplified the exchange</a> by requiring three roundtrips, using RSA, AES-IGE (some weird mode that nobody uses), and Diffie-Hellman, along with a proof of work (the client has to factor a number, probably a DoS protection). Also, they employ some home made function to generate the AES key and IV from nonces generated by the server and the client (server_nonce appears in plaintext during the communication):</p>
<ul>
<li>key = SHA1(new_nonce + server_nonce) + substr (SHA1(server_nonce + new_nonce), 0, 12);</li>
<li>IV = substr (SHA1(server_nonce + new_nonce), 12, 8) + SHA1(new_nonce + new_nonce) + substr (new_nonce, 0, 4);</li>
</ul>
<p>Note that AES-IGE is not an authenticated encryption mode. So they verify the integrity. By using plain SHA1 (nope, not a real MAC) on the plaintext. And encrypting the hash along with the plaintext (yup, pseudoMAC-Then-Encrypt).</p>
<p>The final DH exchange creates the authorization key that will be stored (probably in plaintext) on the client and the server.</p>
<p>I really don't understand why they needed such a complicated protocol. They could have made something like: the client generates a key pair, encrypts the public key with the server's public key, sends it to the server with a nonce, and the server sends back the nonce encrypted with the client's public key. Simple and easy. And this would have provided public keys for the clients, for end-to-end authentication.</p>
<p>About the communication phase: they use some combination of server salt, message id and message sequence number to prevent replay attacks. Interestingly, they have a message key, made of the 128 lower order bits of the SHA1 of the message. That message key transits in plaintext, so if you know the message headers, there is probably some nice info leak there.</p>
<p>The AES key (still in IGE mode) used for message encryption is generated like this:</p>
<p>The algorithm for computing aes_key and aes_iv from auth_key and msg_key is as follows:</p>
<ul>
<li>sha1_a = SHA1 (msg_key + substr (auth_key, x, 32));</li>
<li>sha1_b = SHA1 (substr (auth_key, 32+x, 16) + msg_key + substr (auth_key, 48+x, 16));</li>
<li>sha1_с = SHA1 (substr (auth_key, 64+x, 32) + msg_key);</li>
<li>sha1_d = SHA1 (msg_key + substr (auth_key, 96+x, 32));</li>
<li>aes_key = substr (sha1_a, 0, 8) + substr (sha1_b, 8, 12) + substr (sha1_c, 4, 12);</li>
<li>aes_iv = substr (sha1_a, 8, 12) + substr (sha1_b, 0, 8) + substr (sha1_c, 16, 4) + substr (sha1_d, 0, 8);</li>
</ul>
<p>where x = 0 for messages from client to server and x = 8 for those from server to client.</p>
<p><del>Since the auth_key is permanent, and the message key only depends on the server salt (living 24h), the session (probably permanent, can be forgotten by the server) and the beginning of the message, the message key may be the same for a potentially large number of messages. Yes, <strong>a lot of messages will probably share the same AES key and IV</strong>.</del></p>
<p><strong>Edit: Following Telegram's comment, the AES key and IV will be different for every message. Still, they depend on the content of the message, and that is a very bad design. Keys and initialization vectors should always be generated from a CSPRNG, independent from the encrypted content.</strong></p>
<p><strong>Edit 2: the <a title="protocol diagram" href="https://core.telegram.org/img/mtproto_encryption.png" target="_blank">new protocol diagram</a> makes it clear that the key is generated by a weak KDF from the auth key and some data transmitted as plaintext. There should be some nice statistical analysis to do there.</strong></p>
<p><del><strong>Edit 3: Well, if you send the same message twice (in a day, since the server salt lives 24h), the key and IV will be the same, and the ciphertext will be the same too. This is a real flaw, that is usually fixed by changing IVs regularly (even broken protocols like WEP do it) and changing keys regularly (cf Forward Secrecy in TLS or OTR)</strong></del>. The unencrypted message contains a (time-dependent) message ID and sequence number that are incremented, and the client won't accept replayed messages, or too old message IDs.</p>
<p><strong>Edit 4: Someone <a href="http://habrahabr.ru/post/206900/" target="_blank">found a flaw</a> in the <a title="Web archive for Telegram" href="http://web.archive.org/web/20131220000537/https://core.telegram.org/api/end-to-end" target="_blank">end to end secret chat.</a> The key generated from the Diffie-Hellman exchange was combined with a server-provided nonce: <code>key = (pow(g_a, b) mod dh_prime) xor nonce</code>. With that, the server can perform a MITM on the connection and generate the same key for both peers by manipulating the nonce, thus defeating the key verification. Telegram has updated their protocol description and will fix the flaw. (That nonce was introduced to fix RNG issues on mobile devices).</strong></p>
<p>Seriously, I have never seen anyone use the MAC to generate the encryption key. Even if I wanted to put a backdoor in a protocol, I would not make it so evident...</p>
<p>To sum it up: <strong>avoid at all costs</strong>. There are no new ideas, and they add their flawed homegrown mix of RSA, AES-IGE, plain SHA1 integrity verification, MAC-Then-Encrypt, and a custom KDF. Instead of Telegram, you should use well known and audited protocols, like OTR (usable in IRC, Jabber) or the Axolotl key ratcheting of TextSecure.</p>

    

    
      
      
      

      
    
  </article>
  

  
<div class="pagination">
  <a class="pagination-item older"
     href="/page5">
    Older
  </a>
</div>


</div>
    </main>

    <!-- Optional footer content -->

  </body>
</html>
