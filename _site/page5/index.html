<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Unhandled Expression &middot; Geoffroy Couprie – software security and architecture consultant
    
  </title>

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-117988815-1', 'auto');
  ga('send', 'pageview');
  </script>



  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png" />
<link rel="shortcut icon" href="/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="index">

    <div id="sidebar">
  <header>
    <img src="https://s.gravatar.com/avatar/ed9901b9b80743c05aedf58b4f4926dd?s=200" alt="self" />
    <h1 class="site-title">
      <a href="/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        Unhandled Expression
      </a>
    </h1>
    <p class="lead">Geoffroy Couprie – software security and architecture consultant</p>
  </header>
  <nav id="sidebar-nav-links">
  
    <a class="home-link "
        href="/">Home</a>
  
  

  

  


  
    
  

  
    
      <a class="page-link "
          href="/about.html">About</a>
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  


  
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/architecture.html">Architecture</a>
    
  

  
    
      <a class="category-link "
          href="/category/crypto.html">Crypto</a>
    
  

  
    
      <a class="category-link "
          href="/category/development.html">Development</a>
    
  

  
    
  

  

  
    
      <a class="category-link "
          href="/category/rust.html">Rust</a>
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/security.html">Security</a>
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/videolan.html">VideoLAN</a>
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  <nav id="sidebar-icon-links">
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/tags.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  
    <a id="search-link"
       class="icon"
       title="Search" aria-label="Search"
       href="/search.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
    </a>
  

  <!-- Optional additional links to insert for icons links -->
</nav>
  <p>
  &copy; 2018.
  <a href="/LICENSE.md">MIT License.</a>
</p>

</div>


    <main class="container">
      <div class="content">
  
<div class="pagination">
  <a class="pagination-item newer"
     href="/page4">
    Newer
  </a>
</div>



  

  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/security/2013/10/01/the-rules-of-security-by-obscurity.html">
        The rules of security by obscurity
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">01 Oct 2013</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/security.html">
          Security
        </a>
      
    
  </span>
</div>

    
      <h2>The first rule of security by obscurity is: DON'T</h2>
<p>There, I said it. Now you can stop reading. Or you can continue. But watch where you step.</p>
<p>Security by obscurity is generally frowned upon, because people have relied on it as their only layer of defense. When you think that nobody will be able to reverse engineer your clever code, or find that specific file holding all the secrets, you have already lost. People got quite efficient at reverse engineering and finding secrets.</p>
<p>That's why it is recommended to rely on safer algorithms and techniques to protect your system. They have been tested, and were created especially for that purpose. That can be encryption algorithms, authorization systems, etc.</p>
<h2>The second rule of security by obscurity is: you should not need it</h2>
<p>Defense is hard because of information asymmetry: the attacker often has more information than you to approach the system. That could be 0-day vulnerabilities, or the knowledge that you misconfigured one of your servers. The attacker has basically more time and more money than what you can spend on security.</p>
<p>The tools you have at hand? Patching the code, controlling authorizations, verifying your logs... You get a system that should not be easy to attack even if the attacker is familiar with the underlying software.</p>
<p>Except that the attacker might be well informed on the problems of deploying that particular CMS. Or there's a specific vulnerability you don't know about that is exploited automatically by botnets...</p>
<h2>The third rule of security by obscurity is: DON'T, but...</h2>
<p>The goal of your defense layers is to drive up the cost of an attack. A really motivated attacker will always find a way (with enough ressources, they could break in your office to steal data directly). So, what you want is to make an attack costly, to drive off attackers with less ressources.</p>
<p>And what will security through obscurity provide you? Time! They will provide you with time to defend, and waste the attacker's time. It is in no way enough to protect you, but it can give you a lot of benefits:</p>
<ul>
<li>confuse automated tools: moving some specific files or pages of your CMS out of their default location will prevent most automated attacks. That will not stop human attackers, but they might need to modify their scripts, and we all know that's annoying :p</li>
<li>slow down information gathering: removing the server headers is a pretty standard practice.  Some more sophisticated tools might be able to guess server version and/or framework type in other ways, but basic tools will not.</li>
<li>lie to the attackers to send them through a honeypot. Then, you can observe them, learn about their process and prepare for other attacks.</li>
<li>detect suspect behaviour, like bruteforce queries, and send bogus data instead of rejecting them. That means more data to analyze manually for the adversary.</li>
<li>Are you trying to send encrypted data? Do you really need a public handshake protocol, displaying the whole algorithm negotiation? Sometimes, communicating directly with a pre shared key and pre negotiated algorithms will work just fine, and only show garbage to the attacker.</li>
</ul>
<p>See the pattern there? We already know ressourceful attackers will get past those false defenses. But the point is to make them waste time in basically three ways:</p>
<ul>
<li>forbid automated attacks, they should ressort to manual ways</li>
<li>make them work to get useful information</li>
<li>mess with their heads</li>
</ul>
<p>Security by obscurity is basically the fun side of defense, because you're always looking for ways to annoy the adversary ;)</p>
<h2>The fourth rule of security by obscurity is: you are not the attacker</h2>
<p>While those defense techniques can be useful, be aware that they can significantly hamper your day to day work. They should not prevent you from managing your system correctly. Every "WTF" moment for an attacker might be a "WTF" moment for one of your developers, system administrators, or even worse, one of your users.</p>
<p>Worse, sometimes, it might annoy you, but will be bypassed easily by the adversary (do not underestimate their ability to write clever automated tools).</p>
<p>So, be careful with security by obscurity, do not rely only on it, and have fun annoying the attackers :)</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/crypto/security/2013/08/09/theoretical-definitions-for-crypto-wannabes.html">
        Theoretical definitions for crypto wannabes
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">09 Aug 2013</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/crypto.html">
          Crypto
        </a>
      
    
      &bull;

      
      
      

      
        <a href="/category/security.html">
          Security
        </a>
      
    
  </span>
</div>

    
      <p>Every week, I hear about a new secure software designed to protect your privacy, thwart the NSA/GCHQ and save kittens. Most of the time, though, they're started by people that are very enthusiastic yet unskilled.</p>
<p>They tend to concentrate directly on choosing algorithms and writing code, instead of stepping back and thinking a bit about what they want to develop.</p>
<p>Sure, they probably spent some time saying things like:</p>
<ul>
<li>that piece of data should absolutely be encrypted</li>
<li>users will all have key pairs to authenticate themselves</li>
<li>we should use AES, that's the safest choice (what are theses "modes" you're talking about?)</li>
</ul>
<p>That is not how you design a protocol. That is not how you design a software using encryption. And that is not how you will design the next secure distributed social network.</p>
<p>To design your system, you need three things:</p>
<ul>
<li>a good threat model</li>
<li>theoretical tools addressing the threats</li>
<li>algorithms implementing these theoretical tools</li>
</ul>
<p>As you see, most of the projects only have the third item, and that's insufficient to design a correct system. <em>If you don't have a good threat model, you don't have a good mental model</em> of your users and attackers, their means and their objectives. If you don't have the theoretical tools, you will try to shoehorn your favorite algorithm on the problem without knowing if it really fits (example: using hash algorithms to store passwords :p).</p>
<p>So, in this post, I'll provide those (simplified) theoretical definitions. You will probably recognize some of them.</p>
<h2>High level view</h2>
<p>First, you need to forget notions like "privacy", use any of these terms to describe the properties you want to achieve:</p>
<ul>
<li><strong>authentication</strong>: you can recognize which entity you are communicating with</li>
<li><strong>authorization</strong>: the entity cannot get access to data it has no permission on (note that it is different from authentication)</li>
<li><strong>confidentiality</strong>: the data should not be readable by an entity that has no permission on it (it can be protected by crypto, but also by policies in the code)</li>
<li><strong>integrity</strong>: unauthorized modification of the data can be detected and marked as invalid</li>
<li><strong>non repudiation</strong>: an entity cannot deny it has executed an action</li>
<li><strong>deniability</strong>: an entity _can_ deny it has executed an action</li>
</ul>
<p>Ok, now that we have some basic properties, let's apply them: think for a long time about the actors of the system (users, malicious users, admins, sysadmins, random attacker on the network, etc), what authorizations they have, what they should not get access to, what data moves on the network and between whom.</p>
<p>You should now have a very basic threat model and a rough overview of your system or protocol: you know what part of the network communications should be confidential, you know where you would need to authenticate.</p>
<p>You will now need some ideas about the type of attacks that could happen to your system, because you probably did not think of everything. Separate your systems in logical parts (like "client", and "server", etc), observe them, and observe how they communicate.</p>
<h2>Common attacks</h2>
<h3>Security properties</h3>
<p>Here are some security properties that will be useful when you will try to choose algorithms later:</p>
<ul>
<li><strong>Random oracle</strong>: a system that answers deterministically every question with a random answer from its answer space. You cannot predict what it will answer, but if you send the same question twice, it will answer the same both times.</li>
<li><strong>Perfect secrecy</strong>: for any two plaintext messages of same size, an attacker cannot distinguish which plaintext maps to which ciphertext. Basically, the adversary learns nothing from the ciphertext only.</li>
<li><strong>Semantic security</strong>: same thing as perfect secrecy, except what the adversary learns on the plaintext is negligible. example: One Time Pad</li>
</ul>
<h3>Security tests</h3>
<p>those properties can be tested by creating a "game", where the attacker tries to guess information on the data:</p>
<ul>
<li><strong>IND-CPA</strong> (indistinguishability under the chosen plaintext attack) test: the adversary can generate as many ciphertexts as he wants. Then, he chooses two messages m0 and m1 of same length, those messages are encrypted, and one of the ciphertexts is sent back to him. The adversary should not be able to guess which message was used to generate that ciphertext (note that this is just one way of testing for CPA, there are many other schemes, some with stronger properties)</li>
<li><strong>IND-CCA</strong> (indistinguishability under the chosen ciphertext attack): the attacker can get the decryption of arbitrary ciphertexts, but should not, from this, be able to decrypt any other ciphertext.</li>
</ul>
<h3>Attack patterns</h3>
<p>Here are some common attack types that can be applied to crypto protocols. The list is not exhaustive, and covers only crypto attacks: there are many more ways to attack a system.</p>
<ul>
<li><strong>Replay attacks</strong>: the attacker has observed some valid (encrypted or not) data going on the wire, and tries to send it again. Obviously, it should not be accepted</li>
<li><strong>MITM</strong> (Man In The Middle): the attacker can observe and modify live data running between two actors of the system. In the worst case, the attacker should not be able to forge valid data, decrypt data, or impersonate one of the users. In the best case, it should be detectable.</li>
<li><strong>Oracle attack</strong>: when an algorithm or protocol has a part that can act as an oracle (can be asked something and give answer, like a server), an attacker could exploit flaws in the algorithm to get useful information on the data (then the oracle is not a random oracle). Timing attacks are part of this type of attack. See also padding oracle attacks, or the recent BREACH attack on TLS.</li>
<li><strong>Offline attack</strong>: the attacker got access to some encrypted data (on the wire, or by accessing a disk somewhere), stored it, and tries to decrypt it for an amount of time</li>
</ul>
<p>You should now have a better view of the system: what are the parts of the system that need protection, what attacks they must resist, and what properties they should have.</p>
<p>That means we can go to the next part: choosing the tools to implement the solution.</p>
<h2>General cryptographic functions</h2>
<p>No, we will not choose algorithms right now. That would be too easy :D</p>
<p>We will choose from a list of cryptographic constructions that implement some of the security properties of the system, and combine them to meet all the needed properties:</p>
<ul>
<li><strong>Secure Pseudo Random Function</strong>: function from spaces K (keys) and X (message) to Y (other message space). The basic definition is that if you choose randomly one of these functions (like choosing randomly a k from K), its output will appear totally random (testable with IND-CPA).</li>
<li><strong>Pseudo Random Permutation</strong>: this is a PRF where X and Y are the same space. It is bijective (every y from Y maps to exactly one x from X, and every y is an output of the function), and there exists an efficient inversion function for it (from Y to X). Example: AES (in ECB, which is unsafe for common use)</li>
<li><strong>Message Authentication Code</strong>: defines a pair of algorithms. One of them takes a key k and a message m and outputs a code c. The other algorithm takes k, m, c and outputs True or False. An attacker should not be able to forge a valid c without knowing k. A PRF could be used to construct a MAC system. A hash function too. Example: HMAC</li>
<li><strong>Authenticated encryption</strong>: an encryption function (with semantic security under the CPA) where the attacker cannot forge new ciphertexts that decrypt correctly. Example: AES-GCM.</li>
<li><strong>Hash function</strong>: collision resistance (cannot find different messages m1, m2 so that H(m1) == H(m2), with different collision levels). Not easily invertible. Usually, they are fast. Example: SHA2.</li>
<li><strong>Trapdoor function</strong>: a function that is easy to compute, for which finding its inverse is hard, unless you have specific information. (secure under IND-CCA). examples: RSA, DSA.</li>
<li><strong>Zero knowledge proof</strong>: a way to prove something to the other party in a communication, without giving her any info, except the proof.</li>
</ul>
<p>There are a lot of other constructions, depending on your needs, from low level algorithms like the Diffie Hellman key exchange to higher level protocols like OTR. Again, the constructions will depend on the security properties.</p>
<h2>Choosing the algorithms</h2>
<p>Can we do it now? YES! But there are rules. You must not choose an algorithm because it's hype or because someone said so in an old book. Basically, you choose algorithms that implement the properties you need (like authenticated encryption), and you choose the parameters of the algorithm (key size, exponent, elliptic curve) depending on the strength you need. Basically, a key size can define how much time encrypted data should remain impossible to decrypt. Those parameters also define the performance of the algorithm. Don't choose them without consulting experts, or you will face problems similar to those encountered by the projects that used low RSA exponents (it looks good from a performance standpoint, but it introduces very bad security).</p>
<h2>Am I done now?</h2>
<p>Nope. We have only define some very high level parts. Creating a protocol implies a lot of thoughts on:</p>
<ul>
<li>how you establish the communications</li>
<li>protocol negotiation (version, algorithms, etc)</li>
<li>key exchange</li>
<li>authentication</li>
<li>nonce usage</li>
<li>storing sessions</li>
<li>handling lost connections</li>
<li>renegotiation</li>
<li>closing the connection</li>
<li>etc.</li>
</ul>
<p>As you can see, designing a protocol involves a lot more than choosing a few algorithms. Note that this was only a very rough overview of what you would need to create a safe system. And we did not even start coding!</p>
<p>So, if you want to build the next privacy protecting system, please talk to experts. They don't necessarily want to make you feel bad. They just have a lot of formal tools and the experience needed to see what will not work.</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/crypto/2013/07/09/group-messaging-crypto-and-the-cap-theorem.html">
        Group messaging crypto and the CAP theorem
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">09 Jul 2013</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/crypto.html">
          Crypto
        </a>
      
    
  </span>
</div>

    
      <p>I often play with group messaging ideas, and recently, an interesting perspective came to me, about the relation between these messaging systems and the constraints of the CAP theorem.</p>
<h2>What is the CAP theorem?</h2>
<p><em>Small theoretical background here, feel free to skip if you already know what it is about</em></p>
<p>Otherwise known as Brewer's theorem, indicates that three properties are important in distributed systems:</p>
<ul>
<li>Consistency (all nodes see the same data)</li>
<li>Availability (every request receives a response)</li>
<li>Partition tolerance (the system still works through network splits or node failure)</li>
</ul>
<p>The CAP theorem tells us that a distributed cannot have the three properties at the same time. It is not really a "two out of three" like most people tend to say, but more of a compromise you have to make. Some examples:</p>
<ul>
<li>in traditional databases systems (with a master-slave model), consistency and availability are high (all nodes can answer with th same data), but partition tolerance is weak because the master is a SPOF.</li>
<li>in a fully distributed database (no master model), availability is high (all the nodes can answer), partition tolerance is high (a subset of the cluster could act as the whole database), but consistency is weak (data must be replicated to all the relevant nodes, and that can take time, so the nodes may not see the same data at the same time)</li>
<li>in Bitcoin, the consistency is good (all nodes must agree to the same block chain) and partition tolerance is good (for downloading the block chain), but availability is weak for writing, because a new transaction must first propagates to a large enough set of nodes, then a block must be calculated for the transaction to be stored</li>
</ul>
<p>As you can see, you can shape those properties depending on how you want your system to behave. Maybe you want fast reads, or fast writes, or very strong replication, etc.</p>
<h2>Group messaging constraints</h2>
<p>This has always been a challenge. Traditionally, chat systems follow a client-server model, where the server redistributes all the messages. As we saw previously, that is bad against partition problems. The usual solution is to have multiple servers talking with each other, as we can see in IRC or XMPP.</p>
<p>For a fully distributed messaging system (if we forget for a moment all the nasty NAT problems),  communication becomes a routing problem: making sure the nodes get all the messages fast enough and in the right order. If you're building a distributed Twitter, it's not really a problem, but for an interactive chat system, this becomes really hard. You can try to send your messages directly to all the users in the chat room, but as more people join, sending and receiving all the messages takes more and more time, and so, you sacrifice availability and a bit of consistency (you will not necessarily receive all the messages).</p>
<h2>Group messaging crypto</h2>
<p>The group messaging problems seemed hairy? Let's add crypto in the mix, just for fun! What security properties would we want to add to a messaging system?</p>
<ul>
<li>Authentication: every user knows with whom he is talking</li>
<li>Confidentiality: an external observer cannot see the content of a message</li>
<li>Tampering proof: users can detect when a message has been modified and reject them</li>
<li>Perfect forward secrecy: compromising one key does not compromise the whole conversation or past conversations</li>
</ul>
<p>There are others that we could want, but let's just concentrate on these ones for now. We can separate the messaging in two phases: the discovery, and the transport. The discovery is when nodes begin talking to each other, authenticating each other, establishing session keys, managing key rotation, etc. Note that discovery can happen at any time, as a new node can appear after a long time. The transport is about sending messages safely and verifying messages.</p>
<p>I think we can assume that, once all the nodes have authenticated themselves and agreed on session keys, the transport is the easy part. Whatever the underlying transport system (broadcast, XMPP, SMTP, etc), once you can send, receive and verify messages, everything is easy.</p>
<p>The interesting part is the discovery. That is where the similarity with a distributed system is evident. You want a lot of nodes to start communicating with each other, you want to propagate information to all the nodes (like session keys), you must handle nodes that go up or down, and clusters splitting.</p>
<p>That's where the CAP theorem is useful to understand the constraints of the system.</p>
<p>Group authentication is an availability and partition problem: if you cannot start the communication until all the nodes have authenticated each other, you are vulnerable to slow or failing nodes.</p>
<p>Tampering proof is a consistency problem: all the nodes must know the same signature keys to agree on whether a message is correct or not.</p>
<p>Confidentiality is a consistency and partition problem: if you must reach consensus on a group-wide session key, you have to wait for all the nodes to get the new key (consistency). That happens a lot if you want perfect forward secrecy, where you must change keys regularly. Moreover, in case of partition, the different groups will agree to different keys, and a conflict will appear once the split is over.</p>
<p>As you can see, a security model can help you choose which tools (cryptographic or not) you will use to ensure the safety of the system, but with the distributed system theory, you will be able to predict and recognize the behaviour of the system.</p>
<h2>Some examples</h2>
<p>Let's see how some more or less known system handle that:</p>
<h3>GPG and email</h3>
<p>GPG+email is, at its heart, a secure group messaging system. If we analyze its properties, wen can see that it is very good against partition: SMTP handles splits quite well, it can resend messages if they did not pass, or store them for a few days until the next server is up.</p>
<p>For availability, it doesn't fare very well at high loads if you want to encrypt messages, because you need to encrypt for every host. You cannot take advantage of SMTP's architecture to reduce the load.</p>
<p>It also has very bad consistency. If you want every node to agree on the keys of each user, you have to do one to one offline meetings between each of the participants. In practice, users make a tradeoff here, so the security assumption is not completely true.</p>
<h2>Multi party off the record messaging</h2>
<p>There is a paper you can read about <a title="Multy Party OTR" href="http://www.cypherpunks.ca/~iang/pubs/mpotr.pdf" target="_blank">MP OTR</a>, which builds on the previous OTR algorithm to provide secure multi party communication. That protocol relies on a heavy setup phase where all the nodes authenticate each other and generate a group encryption key.</p>
<p>This model will fare quite well once consensus has been reached: all the nodes know the ephemeral signature keys and the group encryption key.</p>
<p>Unfortunately, in case of a user joining or leaving the chatroom, the whole shutdown and setup process must happen, making the chatroom unavailable in the meantime.</p>
<h2>What about yours?</h2>
<p>I see a lot of new projects appearing lately, with the intention to "fix" chat systems or social networks by building a "secure" distributed system. Unfortunately, most of them do not have a serious background in security or distributed systems. The subject of this article, the CAP theorem, is a very small part of the way we think about distributed systems: people have been researching on the subject for years. Similarly, cryptography and protocols have improved a lot lately.</p>
<p>So, if you are building one of these, take your time, forget the hype, read up a bit about the theory, and think about your model before you make your technological choices. Please don't repeat the worst mistakes.</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/development/general/2013/03/18/my-ideal-job-post.html">
        My ideal job posting
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">18 Mar 2013</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/development.html">
          Development
        </a>
      
    
      &bull;

      
      
      

      
        General
      
    
  </span>
</div>

    
      <p>This post is a translation of <a href="http://blog.humancoders.com/post/44145884680/loffre-demploi-ideale-de-gcouprie" title="L'offre d'emploi idéale de Geoffroy Couprie" target="_blank">something I wrote in French for Human Coders</a>. They asked me what would be the ideal job post from a developer's standpoint:</p>
<p>How whould you write a job announcement attracting good developers? Most recruiters complain that finding the right candidates is an ordeal.</p>
<p>If you ask me, it is due to very old recruitment practices: writing job posts for paper ads (where you pay by the letter), spamming them to as many people as possible, mandating fishy head hunters... This has worked in the past, but things changed. A lot more companies are competing to recruit developers, and many more developers are available, so separating the wheat from the chaff is harder.</p>
<p>We can do better! Let's start from scratch. For most candidates, a job posting is the first contact they'll have with your company. It must be attrctive, exciting! When I read "the company X is the leader on the market of Y", I don't think that they're awesome, I just wonder what they really do.</p>
<p>A job posting is a marketing document. Its purpose is not to filter candidates, but to attract them! And how do you write a marketing document?</p>
<p>YOU. TALK. ABOUT. THE. CLIENT. You talk about his problems, his aspirations, and only then, will you tell him how you will make things better for him. For a job posting, you must do the same. You talk to THE candidate. Not to multiple candidates, not to the head hunter or the HR department, but to the candidate. Talk about the candidate, and only the candidate. When a developer looks for a job, she doesn't want to "work on your backend application" or "maintain the web server". That is what she will do for you. This is what she wants:</p>
<ul>
<li>getting paid to write code</li>
<li>work on interesting technologies</li>
<li>a nice workplace atmosphere</li>
<li>learn</li>
<li>etc.</li>
</ul>
<p>A good job posting should answer the candidate's aspirations, and talk about the career path. Does this job lead to project management? Do you propose in-house training? Is there a career path for expertise in your caompany?</p>
<p>Do you share values with your candidate? I do not mean the values written by your sales team and displayed on the "our values" page of your website. I am talking about the values of the team where the candidate will end up. Do they work in pair programming? Do they apply test driven development? There is no best way to work, the job can be done in many ways, so you must make sure that the candidate will fit right in.</p>
<p>What problem are you trying to solve with your company? Do you create websites that can be managed by anyone? Do you provide secure hosting? Whatever your goal is, talk about it instead of talking about the product. I do not want to read, "our company develops a mobile server monitoring tool", because that is uninteresting. If I read "we spent a lot of time on call for diverse companies, so we understood that mobility is crucial for some system administrators, so we created a tool tailored for moving system administrators", I see a real problem, a motivation to work, a culture that I could identify to.</p>
<p>By talking that way to the candidate, you will filter candidates on motivation and culture instead of filtering on skills. That can be done later, once you see the candidate You did not really think that a resume was a good way to select skilled people, do you?</p>
<p>Here is a good example of fictive job posting, from a company aggregating news for developers, looking for a Rails developer:</p>
<p>"You are a passionnate Ruby on Rails developers, you are proiud of you unit tests, and you enjoy the availability of Heroku's services? That's the same for us!</p>
<blockquote><p>At Company X, we love developers: all of our services are meant for their fulfillment. We propose a news website about various technologies, higly interesting trainings and a job board for startups.</p>
<p>Our employees benefit fully from these services, and make talks in conferences all around France. By directly talking with other developers, they quickly get an extensive knowledge of current technologies.</p>
<p>Our news website is growing fast, so we need help to scale it. The web app uses Heroku and MongoDB, with a CoffeeScript front end. Are you well versed in Rails optimization? If yes, we would love to talk with you!"
</p></blockquote>
<p>Note that I did not talk about years of experience, or a city. I want to hire a Rails developer, not necessarily a french developer. I want someone with experience in optimization, not someone over 27.</p>
<p>With such a job posting, you will receive a lot more interesting employment applications. Now, are you afraid that it will incur a lot more work? The solution in a future post: how to target candidates efficiently? Get away from job boards!</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/ruby/security/2013/02/06/filter-rails-json-input-with-route-constraints.html">
        Filter Rails JSON input with route constraints
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">06 Feb 2013</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        Ruby
      
    
      &bull;

      
      
      

      
        <a href="/category/security.html">
          Security
        </a>
      
    
  </span>
</div>

    
      <p>Following the recent <a title="Vulnerability in JSON Parser in Ruby on Rails 3.0 and 2.3" href="https://groups.google.com/forum/?fromgroups=#!topic/rubyonrails-security/1h2DR63ViGo" target="_blank">YAML parsing vulnerabilities in Rails</a>, I decided to act on an idea I had a few months ago: using route constraints to define strict API contracts in Rails.</p>
<p>Sadly, it does not protect against the YAML parsing problem (and the probable similar vulnerabilities we will see in the following months), because the request is interpreted before going through the route constraints. But it can protect from the <a title="Rails security guide: mass assignment" href="http://guides.rubyonrails.org/security.html#mass-assignment" target="_blank">mass assignment vulnerability</a>., and probably some SQL injections.</p>
<p>Here is the idea: Rails 3 introduced the route constraints, a way to execute fonctions on the request before it is passed to the controllers. By combining it with the json-schema gem, we can filter the JSON input quite easily.</p>
<p>For the following example data:</p>
<p>[sourcecode language="javascript"]<br />
{&quot;echo&quot; : &quot;blah&quot;, &quot;nb&quot; : 1, &quot;data&quot;: [1, 2, 3]}<br />
[/sourcecode]</p>
<p>We can define the following schema:</p>
<p>[sourcecode language="javascript"]<br />
{<br />
    &quot;type&quot;: &quot;object&quot;,<br />
    &quot;$schema&quot;: &quot;http://json-schema.org/draft-03/schema&quot;,<br />
    &quot;id&quot;: &quot;#&quot;,<br />
    &quot;required&quot;: false,<br />
    &quot;additionalProperties&quot;: false,<br />
    &quot;properties&quot;: {<br />
        &quot;data&quot;: {<br />
            &quot;type&quot;: &quot;array&quot;,<br />
            &quot;id&quot;: &quot;data&quot;,<br />
            &quot;required&quot;: false,<br />
            &quot;items&quot;: {<br />
                &quot;type&quot;: &quot;number&quot;,<br />
                &quot;id&quot;: &quot;0&quot;,<br />
                &quot;required&quot;: false<br />
            }<br />
        },<br />
        &quot;echo&quot;: {<br />
            &quot;type&quot;: &quot;string&quot;,<br />
            &quot;id&quot;: &quot;echo&quot;,<br />
            &quot;required&quot;: false<br />
        },<br />
        &quot;nb&quot;: {<br />
            &quot;type&quot;: &quot;number&quot;,<br />
            &quot;id&quot;: &quot;nb&quot;,<br />
            &quot;required&quot;: false<br />
        }<br />
    }<br />
}<br />
[/sourcecode]</p>
<p>(Use the <a title="JSON schema generator" href="http://www.jsonschema.net/" target="_blank">JSON schema generator</a> to create your own)</p>
<p>Save this schema to "data.schema" and add "json-schema" to your Gemfile. You will then be able to filter inputs with code like the following "config/routes.rb":</p>
<p>[sourcecode language="ruby"]<br />
require &quot;json-schema&quot;<br />
class LolJSONConstraint<br />
  def matches?(request)<br />
    if(request.headers[&quot;CONTENT_TYPE&quot;] == &quot;application/json&quot;)<br />
      JSON::Validator.validate(&quot;data.schema&quot;, request.headers[&quot;action_dispatch.request.request_parameters&quot;])<br />
    end<br />
  end<br />
end</p>
<p>Yamlvuln::Application.routes.draw do<br />
  resources :posts, :constraints =&gt; LolJSONConstraint.new<br />
end<br />
[/sourcecode]</p>
<p>The constraint will load the schema, and apply it to the incoming data, and return a 404 error if the JSON is invalid. The "additionalProperties" set to false in the schema is required to refuse the properties you didn't define and protect the application from mass assignment.</p>
<p>If I tried, for example, to send the following JSON to the application, there would be an error:</p>
<p>[sourcecode language="javascript"]<br />
{&quot;echo&quot; : &quot;blah&quot;, &quot;nb&quot; : &quot;UNION ALL SELECT LOAD_FILE(CHAR(34,47,101,116,99,47,112,97,115,115,119,100,34))&quot;, &quot;data&quot;: [1, 2, 3]}<br />
[/sourcecode]</p>
<p>As I said before, it is not safe against the YAML parsing vulnerability. Also, I did not really test the performance of this. But it is still a nice and easy solution for API filtering.</p>

    

    
      
      
      

      
    
  </article>
  

  
<div class="pagination">
  <a class="pagination-item older"
     href="/page6">
    Older
  </a>
</div>


</div>
    </main>

    <!-- Optional footer content -->

  </body>
</html>
