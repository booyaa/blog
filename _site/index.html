<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Unhandled Expression &middot; Geoffroy Couprie ‚Äì software security and architecture consultant
    
  </title>

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-117988815-1', 'auto');
  ga('send', 'pageview');
  </script>



  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png" />
<link rel="shortcut icon" href="/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="index home">

    <div id="sidebar">
  <header>
    <img src="https://s.gravatar.com/avatar/ed9901b9b80743c05aedf58b4f4926dd?s=200" alt="self" />
    <h1 class="site-title">
      <a href="/">
        
        Unhandled Expression
      </a>
    </h1>
    <p class="lead">Geoffroy Couprie ‚Äì software security and architecture consultant</p>
  </header>
  <nav id="sidebar-nav-links">
  
    <a class="home-link  active"
        href="/">Home</a>
  
  

  

  


  
    
  

  
    
      <a class="page-link "
          href="/about.html">About</a>
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  


  
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/architecture.html">Architecture</a>
    
  

  
    
      <a class="category-link "
          href="/category/crypto.html">Crypto</a>
    
  

  
    
      <a class="category-link "
          href="/category/development.html">Development</a>
    
  

  
    
  

  

  
    
      <a class="category-link "
          href="/category/rust.html">Rust</a>
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/security.html">Security</a>
    
  

  
    
  

  
    
      <a class="category-link "
          href="/category/videolan.html">VideoLAN</a>
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  <nav id="sidebar-icon-links">
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/tags.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  
    <a id="search-link"
       class="icon"
       title="Search" aria-label="Search"
       href="/search.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
    </a>
  

  <!-- Optional additional links to insert for icons links -->
</nav>
  <p>
  &copy; 2018.
  <a href="/LICENSE.md">MIT License.</a>
</p>

</div>


    <main class="container">
      <div class="content">
  


  

  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/general/rust/2018/02/02/poc-compiling-to-ebpf-from-rust.html">
        PoC: compiling to eBPF from Rust
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">02 Feb 2018</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        General
      
    
      &bull;

      
      
      

      
        <a href="/category/rust.html">
          Rust
        </a>
      
    
  </span>
</div>

    
      <blockquote class="twitter-tweet"><p lang="en" dir="ltr">guess who has an eBPF tracer written in Rust? This guyüëç <a href="https://t.co/3aE1giGWeK">pic.twitter.com/3aE1giGWeK</a></p>&mdash; Geoffroy Couprie (@gcouprie) <a href="https://twitter.com/gcouprie/status/957332988462882819?ref_src=twsrc%5Etfw">January 27, 2018</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


    

    
      
      
      

      
        <a href="/general/rust/2018/02/02/poc-compiling-to-ebpf-from-rust.html">More &hellip;</a>
      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/rust/2018/01/10/rust-2018-maybe-dont-be-too-stable.html">
        Rust 2018: maybe don't be too stable
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">10 Jan 2018</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/rust.html">
          Rust
        </a>
      
    
  </span>
</div>

    
      <p>I initially did not want to write a post with what I want and foresee for <a href="https://blog.rust-lang.org/2018/01/03/new-years-rust-a-call-for-community-blogposts.html" rel="noopener" target="_blank">Rust in 2018</a>, because I'm already very happy with it! I have spent more than 4 years tinkering with the language, experimenting, and I love the freedom I get when playing with low level stuff. In those 4 years, I discovered a wonderful, welcoming community and made some awesome friends. So, yes, I'm happy with Rust as it is :)</p>
<p>But some of the recent #Rust2018 posts made me react a bit. I'm interested in learning what other people see in Rust, so I read almost all of them, and there's an easy trend to follow. Rust should be stabilized. Rust should be boring and safe. Crates should be stabilized. We should have definitive crates for some purposes like HTTP clients or async programming.<br />
This is not surprising, since there's already been a lot of focus on stability in 2017, with the <a href="https://blog.rust-lang.org/2017/09/18/impl-future-for-rust.html" rel="noopener" target="_blank">impl period</a>, the merge of the <a href="https://github.com/rust-lang/rfcs/blob/master/text/2052-epochs.md" rel="noopener" target="_blank">Rust epochs RFC</a>, and the fact that more and more companies start relying on Rust.<br />
We want Rust to be appealing to (big(ger)) companies, and to that end we need good compatibility between Rust versions, a high quality ecosystem of crates that work on stable Rust versions. We want newcomers to have a well prepared toolbox for their first projects.</p>
<p>Before that stabilization goal appeared, Rust looked a bit chaotic, with new features coming every 6 weeks, new crates popping up here and there, people hacking something quickly and publishing it the next minute. And this is something I love about this language.<br />
People try stuff, cargo lets them publish it easily, Rust makes sure it's running smoothly. Sure, there's a lot of redundant crates, most of them are far from the big "1.0 stable" target, but it's fine.<br />
This language and its community are full of that unabashed optimism that makes newcomers go "hey, should I really try to write my own kernel? OF COURSE I SHOULD". Should I try to make cool stuff with Web Assembly while it barely landed in nightly? YESSSSSS<br />
I have seen over and over shitposting on twitter that ends up with people hacking on a cool new project. I have seen people publish a crate competing with another well known one, that will then send a PR for their idea to the bigger crate the next day.<br />
I am overly enthusiastic about this, to the point that opening <a href="http://reddit.com/r/rust/" rel="noopener" target="_blank">/r/rust</a>  often feels like Christmas: what new toys will we get today?</p>
<p>So, to be clear, I am all for getting more stuff stable. We need a stable, asynchronous hyper. We need futures to work. We need impl trait and various other Rust features that will appear in the following months or years. What we do not need is the attitude that wants everything to crystallize.<br />
How many times have I seen people criticising the "yet another" asynchronous IO/command line argument system/web framework/parser, with the usual arguments that this is lost focus, redundant, that why didn't they try to do that in $BIG_PROJECT. This is fine.<br />
Go on, make other parser libraries to compete with nom, keep me on my toes. Try other approaches than tokio. Test different approaches to writing web applications.</p>
<p>The underlying idea for me is that Rust is still incredibly young, extremely enthusiastic, and we still don't fully know how to write Rust. So, yes, we need some parts of Rust to stabilize, but we must balance that with its movement. What is stable and "the way we do things" now might not be the way to go in a year or so.</p>
<p>Let people experiment and lose focus. Keep hacking on cool stuff.</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/general/2017/08/23/adventures-in-logging.html">
        Adventures in logging
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">23 Aug 2017</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        General
      
    
  </span>
</div>

    
      <p><img src="/assets/truck_loaded_with_logs_on_logging_road_bc_1936.jpg" alt="" width="525" height="279" class="aligncenter size-full wp-image-1000" /></p>
<p>After working on the <a href="https://github.com/sozu-proxy/sozu">S≈çzu¬†HTTP reverse proxy</a> for a while, I came up with <a href="https://github.com/sozu-proxy/sozu/blob/57f99560a85b707c867de6206635b1f8f166e078/lib/src/logging.rs">an interesting approach to logging</a>. Now why would I come up with my own logger, when there are existing solutions in Rust? Mainly, <a href="https://crates.io/crates/log">log</a> and <a href="https://crates.io/crates/slog">slog</a>. That logging library grew up from testing things out with <code>log</code>, and changing requirements along the way.</p>
<h1>Beginning with log and env_logger</h1>
<p>Like a lot of other Rust developers, I started out with <code>log</code> and <code>env_logger</code>:</p>
<p><br />
#[macro_use]<br />
extern crate log;<br />
extern crate env_logger;</p>
<p>fn main() {<br />
  env_logger::init().unwrap();</p>
<p>  info!(&quot;starting up&quot;);<br />
}<br />
</p>
<p>It's nice and easy: every library that depends on <code>log</code> will use that same set of logging macros (error, info, warn, debug, trace) that will use whatever global logger was defined. Here we use <code>env_logger</code> to define one.</p>
<p><code>env_logger</code> is useful because it can apply a filter to the log, from an<br />
environment variable:</p>
<p>[code lang=text]<br />
# will show the logs above info level<br />
RUST_LOG=info ./main</p>
<p># will show the logs above info level, but also logs above debug level<br />
# for the dependency &#039;dep1&#039;<br />
RUST_LOG=info,dep1=debug ./main<br />
[/code]</p>
<p>You can also define the filter <a href="http://rust-lang-nursery.github.io/log/env_logger/#enabling-logging">by module</a> or <a href="http://rust-lang-nursery.github.io/log/env_logger/#filtering-results">apply a regular expression</a>.</p>
<h1>Custom formatter</h1>
<p><code>env_logger</code> allows you to <a href="https://docs.rs/env_logger/0.4.2/env_logger/struct.LogBuilder.html">build your own log formatter</a>. This feature is especially important for me, as I like to <a href="https://www.clever-cloud.com/blog/engineering/2016/05/23/let-your-logs-help-you/">add metadata to my logs</a>.</p>
<p>Defining a custom formatter with <code>env_logger</code> is quite straightforward:</p>
<p>[code lang=text]<br />
let format = |record: &amp;LogRecord| {<br />
  format!(&quot;{} - {}&quot;, record.level(), record.args())<br />
};</p>
<p>let mut builder = LogBuilder::new();<br />
builder.format(format).filter(None, LogLevelFilter::Info);</p>
<p>if env::var(&quot;RUST_LOG&quot;).is_ok() {<br />
  builder.parse(&amp;env::var(&quot;RUST_LOG&quot;).unwrap());<br />
}</p>
<p>builder.init().unwrap();<br />
[/code]</p>
<p>It is easily combined with the filtering and usage of the <code>RUST_LOG</code> environment variable.</p>
<h1>Where things get annoying: reducing allocations</h1>
<p>If you take a look at <code>env_logger</code>, you'll realize that it will allocate a <code>String</code> for every log line that will be written, using a <a href="https://docs.rs/env_logger/0.4.2/env_logger/struct.LogBuilder.html#method.format">formatting closure</a>.</p>
<p>Let's get one thing out of the way first: I completely agree with the idea you should not try to optimize stuff too much. But I'm in the case of a networking component that will handle a lot of traffic. I had debugging sessions where I generated tens of gigabytes of logs in a few seconds, and needed almost all of them, to debug async IO issues. In those cases, the time spent allocating and deallocating log lines becomes relevant.</p>
<p>So, how would I get a custom log formatter that does not allocate much? As it turns out, when you tell <code>log</code> to use your logger with <a href="https://docs.rs/log/0.3.8/log/fn.set_logger.html"><code>log::set_logger</code></a>, it requires something that implements <a href="https://docs.rs/log/0.3.8/log/trait.Log.html">Log</a>. The logger's <code>log</code> method receives a <a href="https://docs.rs/log/0.3.8/log/struct.LogRecord.html">LogRecord</a>, a structure that's created on the fly from <a href="https://docs.rs/log/0.3.8/log/struct.LogLocation.html">LogLocation</a>, <a href="https://docs.rs/log/0.3.8/log/struct.LogMetadata.html">LogMetadata</a> and <a href="https://doc.rust-lang.org/nightly/core/fmt/struct.Arguments.html">Arguments</a>.<br />
The first two are internal to <code>log</code>, I can't create them myself. The last one is interesting.</p>
<p><code>Arguments</code> can be created from the <a href="https://doc.rust-lang.org/nightly/std/macro.format_args.html">format_args macro</a>. That structure will roughly contain the format string split in the various substrings that appear between arguments. if you do <code>println!("hello {}!", name)</code>, you would get a structure that contains <code>"hello "</code>, the content of <code>name</code> and <code>"!"</code>. <code>println!</code> and other macros use this.</p>
<p>You can then use that <code>Arguments</code> with <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_fmt"><code>io::Write::write_fmt</code></a> to write it directly to, say, a file or a socket. And it is implemented so that <a href="https://doc.rust-lang.org/nightly/src/core/fmt/mod.rs.html#948-986">the individual parts are written one after another instead of allocating one big string</a>.</p>
<p>So, how do I use that?</p>
<p>Well, it turns out that, basically, I can't. If I implement <a href="https://docs.rs/log/0.3.8/log/trait.Log.html">Log</a>, I can get a <a href="https://docs.rs/log/0.3.8/log/struct.LogRecord.html">Logrecord</a> which gives me a <code>&amp;amp;Arguments</code>, while <a href="https://doc.rust-lang.org/nightly/std/fmt/fn.write.html">write</a> requires a <code>Arguments</code>. So now I have to clone it, which defeats a bit the purpose.</p>
<h1>So let's write our own then</h1>
<p>There was another reason for the custom logging library: <a href="https://github.com/rust-lang-nursery/log/commit/a16173429dab789407328b682c3db30d84c5a03c">using a custom logging backend</a>. Having the option between stdout and stderr is fine, but I might want to send them to a file or a socket.</p>
<p>So I started writing a specific logging library for sozu. First, <a href="https://github.com/sozu-proxy/sozu/blob/57f99560a85b707c867de6206635b1f8f166e078/lib/src/logging.rs#L95-L343">copying the log filtering from env_logger</a>. That part is mostly straightforward, but that's still a lot of code to copy around.</p>
<p>The <a href="https://github.com/sozu-proxy/sozu/blob/57f99560a85b707c867de6206635b1f8f166e078/lib/src/logging.rs#L387-L445">logging macros</a> specify a logging level then they all call the same common macro.</p>
<p>[code lang=text]<br />
#[macro_export]<br />
macro_rules! error {<br />
    ($format:expr, $($arg:tt)*) =&gt; {<br />
        log!($crate::logging::LogLevel::Error, $format, &quot;ERROR&quot;, $($arg)*);<br />
    };<br />
    ($format:expr) =&gt; {<br />
        log!($crate::logging::LogLevel::Error, $format, &quot;ERROR&quot;);<br />
    };<br />
}<br />
[/code]</p>
<p>The <a href="https://github.com/sozu-proxy/sozu/blob/57f99560a85b707c867de6206635b1f8f166e078/lib/src/logging.rs#L348-L365">main logging macro</a> has two interesting parts. First, we define some static metadata (that's coming from the log crate):</p>
<p>[code lang=text]<br />
static _META: $crate::logging::LogMetadata = $crate::logging::LogMetadata {<br />
  level:  $lvl,<br />
  target: module_path!(),<br />
};<br />
[/code]</p>
<p>That object will not be allocated over and over, all the data in there will be defined at compile time.</p>
<p>Then we call the logger itself (ignore the line with <code>try_lock</code> for now):</p>
<p>[code lang=text]<br />
if let Ok(mut logger) = LOGGER.try_lock() {<br />
  logger.log(<br />
    &amp;_META,<br />
    format_args!(<br />
      concat!(&quot;{}\t{}\t{}\t{}\t{}\t&quot;, $format, &#039;\n&#039;),<br />
        ::time::now_utc().rfc3339(), ::time::precise_time_ns(), *$crate::logging::PID,<br />
        $level_tag, *$crate::logging::TAG));<br />
}<br />
[/code]</p>
<p>So we give this metadata structure to our logger, then we make an <code>Arguments</code> structure with <code>format_args!</code>. The <a href="https://doc.rust-lang.org/std/macro.concat.html">concat!</a> macro is there to concatenate the formatting string with the custom prefix. That way, I could write <code>debug!("hello {}", name)</code> and have the resulting format string be <code>"{}\t{}\t{}\t{}\t{}\thello {}\n"</code>, generated at compile time and transformed through the <code>format_args</code> call.</p>
<p>I added the date in ISO format, along with a monotonic timestamp (that becomes handy when multiple workers might write logs concurrently), the process identifier, the log level and a process wide logging tag (to better identify workers).</p>
<p>So this starts looking good, right? Now how do we write this to configurable backends? Some backends already implement <code>io::Write</code>, <a href="https://github.com/sozu-proxy/sozu/blob/57f99560a85b707c867de6206635b1f8f166e078/lib/src/logging.rs#L49-L68">others will need an intermediary buffer</a>:</p>
<p>[code lang=text]<br />
pub fn log&lt;&#039;a&gt;(&amp;mut self, meta: &amp;LogMetadata, args: Arguments) {<br />
    if self.enabled(meta) {<br />
        match self.backend {<br />
            LoggerBackend::Stdout(ref mut stdout) =&gt; {<br />
                stdout.write_fmt(args);<br />
            },<br />
            LoggerBackend::Unix(ref mut socket) =&gt; {<br />
                socket.send(format(args).as_bytes());<br />
            },<br />
            LoggerBackend::Udp(ref mut socket, ref address) =&gt; {<br />
                socket.send_to(format(args).as_bytes(), address);<br />
            }<br />
            LoggerBackend::Tcp(ref mut socket) =&gt; {<br />
                socket.write_fmt(args);<br />
            },<br />
        }<br />
    }<br />
}<br />
[/code]</p>
<p>For Unix sockets and UDP, instead of allocating on the fly, it should probably use a buffer (hey, anyone wants to implement that?). Stdout and a TcpStream can be written to directly. Adding buffers might still be a good idea here, depending on what you want, because that write could fail. Would you like a logger that will send a partial log if it can't write on the socket, or one using a buffer that can be filled up?</p>
<p>So, now, what's next? Originally, sozu worked as one process with multiple threads, but evolved as a bunch of single threaded processes. But that raises an interesting question. How do you write logs concurrently?</p>
<h1>Highly concurrent logs</h1>
<p>It turns out that problem is not really easy. Most solutions end up in this list:</p>
<ul>
<li>every thread or process writes to stdout or a file at the same time</li>
<li>synchronized access to the logging output</li>
<li>one common logger everybody sends to</li>
<li>every thread or process has its own connection to syslog (or even its own file to write to)</li>
</ul>
<p>The first solution is easy, but has a few issues. First, writing to stdout is slow, and it can quickly overwhelm your terminal (yes, I know you can redirect to a file). Second, it's not really synchronized, so you might end up with incoherently interleaved log lines.</p>
<p>So we often move to the second solution, where access to the logging stream is protected by a mutex. Now you get multiple threads or processes that might spend their time waiting on each other for serializing and writing logs. Having all threads sharing one lock can quickly affect your performance. It's generally a better idea to have every thread or process running independently from the others (it's one of the principles in sozu's architecture, you can learn more about it <a href="https://www.youtube.com/watch?v=Cl_fqWZTYUA">in this french talk</a>).</p>
<p>Alright then, moving on to the third solution: let's have one of the threads or processes handle the logging, and send the logs to it via cross thread channels or IPC. That will surely be easier than having everybody share a lock, right? This is also intersting because you can offload serialization and filtering to the logging thread. Unfortunately, that means one thread will handle <em>all</em> the logs, and it can be overwhelming. That also means a lot of data moving between workers (if using processes).</p>
<p>The last solution relies on external services: use the syslog daemon on your system, or a log aggregator somewhere on another machine, that every worker will send the logs to. Let that service interleave logs, and maybe scale up if necessary. Since in a large architecture, you might have such an aggregator, talking to it directly might be a good idea (oh hey BTW I wrote <a href="https://github.com/geal/rust-syslog">a syslog crate</a> if you need).</p>
<p>With sozu, I ended up with a mixed solution. You can send the logs to various backends. If you choose stdout, then all workers will write to it directly without synchronization which will be mostly fine if you don't have a large traffic. But if you want, each worker can open its own connection to the logging service.</p>
<p>Now that concurrency is taken care of, there's a last issue that has annoyed me for months: how to use the logger from everywhere in the code, when it's obviously one big global mutable object?</p>
<h1>the dreaded logging singleton</h1>
<p>One thing I like about the macros from the log crate: you can use them anywhere in your code, and it will work. The other approach, used in languages like Haskell, or proposed by <a href="https://crates.io/crates/slog">slog</a>, is to carry your logger around, in function arguments or structure members. I can understand the idea, but I don't like it much, because I'll often need to add a debug call anywhere in the code, and when it's deep in a serie of five method calls, with those methods coming from traits implemented here and there, updating the types quickly gets annoying.</p>
<p>So, even if the idea of that global mutable logger singleton usually looks like a bad pattern, it can still be useful. In log, the <a href="https://github.com/rust-lang-nursery/log/blob/master/src/macros.rs#L41-L57">log macro</a> calls the <code>log::Log::log</code> method, getting the logger instance from the <a href="https://github.com/rust-lang-nursery/log/blob/master/src/lib.rs#L1217-L1226">logger method</a>. That method gets the logger instance from <a href="https://github.com/rust-lang-nursery/log/blob/master/src/lib.rs#L292-L297">a global pointer to the logger</a>, with an atomic integer used to indicate if the logger was initialized:</p>
<p>[code lang=text]<br />
static mut LOGGER: *const Log = &amp;NopLogger;<br />
static STATE: AtomicUsize = ATOMIC_USIZE_INIT;</p>
<p>const UNINITIALIZED: usize = 0;<br />
const INITIALIZING: usize = 1;<br />
const INITIALIZED: usize = 2;</p>
<p>[...]</p>
<p>pub fn logger() -&gt; &amp;&#039;static Log {<br />
    unsafe {<br />
        if STATE.load(Ordering::SeqCst) != INITIALIZED {<br />
            static NOP: NopLogger = NopLogger;<br />
            &amp;NOP<br />
        } else {<br />
            &amp;*LOGGER<br />
        }<br />
    }<br />
}<br />
[/code]</p>
<p>So how can that global mutable pointer be used from any thread? That's because <a href="https://github.com/rust-lang-nursery/log/blob/c4faf3dbb003d004699f378ee395c81ea03f9619/src/lib.rs#L921">the Log trait requires Send and Sync</a>. As a <a href="https://doc.rust-lang.org/beta/nomicon/send-and-sync.html">reminder</a>, <code>Send</code> means it can be sent to another thread, <code>Sync</code> means it can be shared between threads.</p>
<p>That's a cool trick, but usually we employ <a href="https://github.com/sozu-proxy/sozu/blob/57f99560a85b707c867de6206635b1f8f166e078/lib/src/logging.rs#L13-L17">another pattern</a>:</p>
<p>[code lang=text]<br />
lazy_static! {<br />
  pub static ref LOGGER: Mutex&lt;Logger&gt; = Mutex::new(Logger::new());<br />
  pub static ref PID:    i32           = unsafe { libc::getpid() };<br />
  pub static ref TAG:    String        = LOGGER.lock().unwrap().tag.clone();<br />
}<br />
[/code]</p>
<p><a href="https://crates.io/crates/lazy_static">lazy_static</a> allows you to define static variables that will be initialized at runtime, at first access (using the same pattern as log with <a href="https://doc.rust-lang.org/std/sync/struct.Once.html">std::sync::Once</a>. Since our logger's <a href="https://github.com/sozu-proxy/sozu/blob/57f99560a85b707c867de6206635b1f8f166e078/lib/src/logging.rs#L49">log method</a> needs an <code>&amp;amp;mut</code>, it's wrapped in a Mutex. That's where the <a href="https://github.com/sozu-proxy/sozu/blob/57f99560a85b707c867de6206635b1f8f166e078/lib/src/logging.rs#L356">call to try_lock</a> comes from.</p>
<p>We might think the mutex is costly compared to log's solution, but remember that the logger instance has to be <code>Sync</code>, so depending on your implementation, there might be some synchronization somewhere. Except that for sozu, it's not the case! Each worker is single threaded, and has its own instance of the logger (possibly with each of them a connection to the logging service). Can't we have a logging system that does not require that mutex used everywhere?</p>
<h1>Removing the last Mutex</h1>
<p>This is a problem that annoyed me for months. It's not that I really mind the cost of that mutex (since no other thread ever touches it). It's just that I'd feel better not using one when I don't need it :)</p>
<p>And the solution to that problem got quite interesting. To mess around a bit, here's a playground of the logging solution based on <a href="http://play.integer32.com/?gist=4e9a8f30cdaae10b096e445f1e2ec8bd">lazy_static</a>. You'll see why the code in <code>Foo::modify</code> is important.</p>
<p>There's a feature you can use to have a global variable available anywhere in a thread: <a href="https://doc.rust-lang.org/std/thread/struct.LocalKey.html">thread_local</a>. It uses thread local storage with an <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html">UnsafeCell</a> to initialize and provide a variable specific to each thread:</p>
<p>[code lang=text]<br />
thread_local!(static FOO: RefCell&lt;u32&gt; = RefCell::new(1));</p>
<p>FOO.with(|f| {<br />
    assert_eq!(*f.borrow(), 1);<br />
    *f.borrow_mut() = 2;<br />
});<br />
[/code]</p>
<p>So I tried to use this with my logger, but encountered an interesting bug, as you can see in <a href="http://play.integer32.com/?gist=fa4995e189ea3394a6f1115b17ba8ee7">another playground</a>. I replaced my logging macro with this:</p>
<p>[code lang=text]<br />
#[macro_export]<br />
macro_rules! log {<br />
    ($format:expr, $($arg:tt)+) =&gt; ({<br />
        {<br />
            LOGGER.with(|l| {<br />
                l.borrow_mut().log(<br />
                    format_args!(<br />
                        concat!(&quot;\t{}\t&quot;, $format, &#039;\n&#039;),<br />
                        &quot;a&quot;, $($arg)+));<br />
            });<br />
        }<br />
    });<br />
}<br />
[/code]</p>
<p>And got this error:</p>
<p>[code lang=text]<br />
error[E0502]: cannot borrow `self` as immutable because `self.opt.0` is also borrowed as mutable<br />
  --&gt; src/main.rs:36:21<br />
   |<br />
36 |         LOGGER.with(|l| {<br />
   |                     ^^^ immutable borrow occurs here<br />
...<br />
54 |         if let Some(ref mut s) = self.opt {<br />
   |                     --------- mutable borrow occurs here<br />
55 |             log!(&quot;changing {} to {}&quot;, self.bar, new);<br />
   |             -----------------------------------------<br />
   |             |                         |<br />
   |             |                         borrow occurs due to use of `self` in closure<br />
   |             in this macro invocation<br />
56 |         }<br />
   |         - mutable borrow ends here<br />
[/code]</p>
<p>When implementing this inside sozu's source, I got about 330 errors like this one... So what happened? That <a href="https://doc.rust-lang.org/std/thread/struct.LocalKey.html#method.with">with method</a> requires a closure. Since we use a macro, if we use <code>self.bar</code> as argument, it will appear inside the closure. That becomes an issue with anything that has been already mutably borrowed somewhere.</p>
<p>I tried a few things, like calling <code>format_args</code> outside the closure, but I get the error <code>error[E0597]: borrowed value does not live long enough</code>. This is apparently <a href="https://github.com/rust-lang/rust/issues/42253">a common problem with format_args</a>.</p>
<p>But the real solution came from <a href="https://twitter.com/tomaka17">tomaka</a>, with some macro trickery, as seen in <a href="http://play.integer32.com/?gist=ea040e83ea680678c75113a73ad9ef82">one last playground</a>:</p>
<p>[code lang=text]<br />
#[macro_export]<br />
macro_rules! log {<br />
    ($format:expr $(, $args:expr)*) =&gt; ({<br />
        log!(__inner__ $format, [], [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v]<br />
             $(, $args)*)<br />
    });</p>
<p>    (__inner__ $format:expr, [$($transformed_args:ident),*], [$first_ident:ident $(, $other_idents:ident)*], $first_arg:expr $(, $other_args:expr)*) =&gt; ({<br />
        let $first_ident = &amp;$first_arg;<br />
        log!(__inner__ $format, [$($transformed_args,)* $first_ident], [$($other_idents),*] $(, $other_args)*);<br />
    });</p>
<p>    (__inner__ $format:expr, [$($final_args:ident),*], [$($idents:ident),*]) =&gt; ({<br />
        LOGGER.with(move |l| {<br />
          //let mut logger = *l.borrow_mut();<br />
          l.borrow_mut().log(<br />
            format_args!(<br />
              concat!(&quot;\t{}\t&quot;, $format, &#039;\n&#039;),<br />
              &quot;a&quot; $(, $final_args)*));<br />
        });<br />
    });<br />
}<br />
[/code]</p>
<p>The basic idea is that we could avoid the borrowing issue by doing an additional borrow. But since some of the arguments might by expressions (like <code>1+1</code> or <code>self.size</code>), we will store the reference to it in a local variable, with <code>let $first_ident = &amp;amp;$first_arg;</code>.</p>
<p>We cannot create variable or function names in macros out of thin air (sadly, because that would be extremely useful), so we instead do recursive macros calls, consuming arguments one after another.<br />
In <code>[$($transformed_args:ident),*], [$first_ident:ident $(, $other_idents:ident)*], $first_arg:expr $(, $other_args:expr)*</code>,<br />
<code>transformed_args</code> accumulates the idents (variable names) in which we stored the data.</p>
<p><code>[$first_ident:ident $(, $other_idents:ident)*]</code> is matching on the list that started as <code>[a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v]</code>, to get the first one in that list (storing it in <code>$first_ident</code>), and using it as variable names. As you might have guessed, that means I won't be able to use a log line with more than 21 arguments. That's a limitation I can live with.</p>
<p>The <code>$first_arg:expr $(, $other_args:expr)*</code> part matches on the log call's arguments, and gets the first in the list as <code>$first_arg</code>. We then use those in the line <code>let $first_ident = &amp;amp;$first_arg;</code> and recursively call <code>log!</code>, adding the variable name <code>$first_ident</code> to the list of transformed arguments, and the rest of the variable names list and the log call's arguments:</p>
<p>[code lang=text]<br />
log!(__inner__ $format, [$($transformed_args,)* $first_ident], [$($other_idents),*] $(, $other_args)*);<br />
[/code]</p>
<p>Once all of the logger's arguments are consumed, we can call <code>format_args</code> on the list of <code>$transformed_args</code>:</p>
<p>[code lang=text]<br />
(__inner__ $format:expr, [$($transformed_args:ident),*], [$($idents:ident),*]) =&gt; ({<br />
    LOGGER.with(move |l| {<br />
            //let mut logger = *l.borrow_mut();<br />
            l.borrow_mut().log(<br />
                    format_args!(<br />
                        concat!(&quot;\t{}\t&quot;, $format, &#039;\n&#039;),<br />
                        &quot;a&quot; $(, $transformed_args)*));<br />
            });<br />
    });<br />
});<br />
[/code]</p>
<p>and it works!</p>
<p>So, that last part may not be completely relevant to your logger implementation, but I thought<br />
it was quite cool :)</p>
<p>Despite my issues with the log crate, it's quite useful and supported by a lot of libraries. It is currently getting a lot better as part of the <a href="https://internals.rust-lang.org/t/crate-evaluation-for-2017-05-16-log/5185">libz blitz</a>. I'd also encourage you to check out <a href="https://crates.io/crates/slog">slog</a>. I haven't felt the need to integrate it in sozu yet, but it can be interesting for new projects, as it comes with an ecosystem of composable libraries to extend it.</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/general/rust/2017/07/12/how-to-rewrite-you-project-in-rust.html">
        How to rewrite your project in Rust
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">12 Jul 2017</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        General
      
    
      &bull;

      
      
      

      
        <a href="/category/rust.html">
          Rust
        </a>
      
    
  </span>
</div>

    
      <p>In a <a href="https://unhandledexpression.com/2017/07/10/why-you-should-actually-rewrite-it-in-rust/">previous post</a>, I explained why rewriting existing software in Rust could be a good idea. The main point being that you should not rewrite the whole application, but replace the weaker parts without disturbing most of the code, to strengthen the codebase without disruption.</p>
<p>I also provided pointers to projects where other people and I did it succesfully, but without giving too many details. So let's get a real introduction to Rust rewrites now. This article requires a little bit of knowledge about Rust, but you should be able to follow it even as a<br />
beginner.</p>
<p>As a reminder, here are the benefits Rust bring into a rewrite:</p>
<ul>
<li>it can easily call C code</li>
<li>it can easily be called by C code (it can export C compatible functions and structures)</li>
<li>it does not need a garbage collector</li>
<li>if you want, it does not even need to handle allocations</li>
<li>the Rust compiler can produce static and dynamic libraries, and even object files</li>
<li>the Rust compiler avoids most of the memory vulnerabilities you get in C (yes, I had to mention it)</li>
<li>Rust is easier to maintain than C (this is discutable, but not the point of this article)</li>
</ul>
<p>As it turns out, this is more or less the plan to replace C code with Rust:</p>
<ul>
<li>import C structures and functions in Rust</li>
<li>import Rust structures and functions from C</li>
<li>reuse the host application's memory allocations whenever possible</li>
<li>write code (yes, we have to do it at some point)</li>
<li>produce artefacts that can be linked with the host application</li>
<li>integrate with the build system</li>
</ul>
<p>We'll see how to apply this with examples from the Rust VLC plugin.</p>
<h2>Import C structures and functions in Rust</h2>
<p>Rust can easily use C code directly, by writing functions and structures definitions. A lot of the techniques you would use for this come from the <a href="https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html">"unsafe Rust" chapter</a> of "The Rust Programming Language" book. For the following C code:</p>
<p>[code lang=C]<br />
struct vlc_object_t {<br />
    const char   *object_type;<br />
    char         *header;<br />
    int           flags;<br />
    bool          force;<br />
    libvlc_int_t *libvlc;<br />
    vlc_object_t *parent;<br />
};<br />
[/code]</p>
<p>You would get the following Rust structure:</p>
<p>[code lang=C]<br />
extern crate libc;<br />
use libc::c_char;</p>
<p>#[repr(C)]<br />
pub struct vlc_object_t {<br />
  pub psz_object_type: *const c_char,<br />
  pub psz_header:      *mut c_char,<br />
  pub i_flags:         c_int,<br />
  pub b_force:         bool,<br />
  pub p_libvlc:        *mut libvlc_int_t,<br />
  pub p_parent:        *mut vlc_object_t,<br />
}<br />
[/code]</p>
<p>the <code>#[repr(C)]</code> tag indicates to the compiler that the structure should have a memory layout similar to the one generated by a C<br />
compiler. We import types from the libc crate, like <code>c_char</code>. Those types are platform dependent (with their different form already handled in libc). Here, we use a lot of raw pointers (indicated by <code>*</code>), which means by using this structure directly, we're basically writing C, which is no good! A good approach, as we'll see later, is to write safer wrappers above those C bindings.</p>
<p>Importing C functions is quite straightforward too:</p>
<p>[code lang=C]<br />
ssize_t  vlc_stream_Peek(stream_t *, const uint8_t **, size_t);<br />
ssize_t  vlc_stream_Read(stream_t *, void *buf, size_t len);<br />
uint64_t vlc_stream_Tell(const stream_t *);<br />
[/code]</p>
<p>These C function declarations would get translated to:</p>
<p>[code lang=C]<br />
#[link(name = &quot;vlccore&quot;)]<br />
extern {<br />
  pub fn vlc_stream_Peek(stream: *mut stream_t, buf: *mut *const uint8_t, size: size_t) -&gt; ssize_t;<br />
  pub fn vlc_stream_Read(stream: *mut stream_t, buf: *const c_void, size: size_t) -&gt; ssize_t;<br />
  pub fn vlc_stream_Tell(stream: *const stream_t) -&gt; uint64_t;<br />
}<br />
[/code]</p>
<p>The <code>#[link(name = "vlccore")]</code> tag indicates to which library we are linking. It is equivalent to passing a <code>-lvlccore</code> argument to the linker. Libvlccore is a library all VLC plugins must link to. Those functions are declared like regular Rust functions, but like the previous structures, will mainly work on raw pointers.</p>
<h3>bindgen</h3>
<p>You can always write all your bindings manually like this, but when the amount of code to import is a bit large, it can be a good idea to employ the awesome <a href="https://github.com/servo/rust-bindgen">bindgen</a> tool, that will generate Rust code from C headers.</p>
<p>It can work as a command line tool, but can also work at compile time from a <a href="http://doc.crates.io/build-script.html">build script</a>. First, add the dependency to your <code>Cargo.toml</code> file:</p>
<p>[code lang=toml]<br />
[build-dependencies.bindgen]<br />
version = &quot;^0.25&quot;<br />
[/code]</p>
<p>You can then write your build script like this:</p>
<p>[code lang=C]<br />
extern crate bindgen;<br />
use std::fs::File;<br />
use std::io::Write;<br />
use std::path::Path;</p>
<p>fn main() {<br />
  let include_arg = concat!(&quot;-I&quot;, env!(&quot;INCLUDE_DIR&quot;));<br />
  let vlc_common_path = concat!(env!(&quot;INCLUDE_DIR&quot;), &quot;/vlc_common.h&quot;);</p>
<p>  let _ = bindgen::builder()<br />
    .clang_arg(include_arg)<br />
    .clang_arg(&quot;-include&quot;)<br />
    .clang_arg(vlc_common_path)<br />
    .header(concat!(env!(&quot;INCLUDE_DIR&quot;), &quot;/vlc_block.h&quot;))<br />
    .hide_type(&quot;vlc_object_t&quot;)<br />
    .whitelist_recursively(true)<br />
    .whitelisted_type(&quot;block_t&quot;)<br />
    .whitelisted_function(&quot;block_Init&quot;)<br />
    .raw_line(&quot;use ffi::common::vlc_object_t;&quot;)<br />
    .use_core()<br />
    .generate().unwrap()<br />
    .write_to_file(&quot;src/ffi/block.rs&quot;);<br />
}<br />
[/code]</p>
<p>So there's a lot to unpack here, because bindgen is very flexible:</p>
<ul>
<li>we use <code>clang_arg</code> to pass the include folder path and pre include a header everywhere (<code>vlc_common.h</code> is included pretty puch everywhere in VLC)</li>
<li>the <code>header</code> method specifies the header from which we will import definitions</li>
<li><code>hide_type</code> prevents redefinition of elements we already defined (liek the ones from the common header)</li>
<li><code>whitelisted_type</code> and <code>whitelisted_function</code> specify types and functions for which bindgen will create definitions</li>
<li><code>raw_line</code> writes its argument at the top of the file. I apply it to reuse definitions from other files</li>
<li><code>write_to_file</code> writes the whole definition to the specified path</li>
</ul>
<p>You can apply that process to any C header you must import. With the build script, it can run every time the library is compiled, but be careful, generating a lot of headers can take some time. It might be a good idea to pregenerate them and commit the generated files, and update them from time to time.</p>
<p>It is usually a good idea to separate the imported definitions in another crate with the <code>-sys</code> suffix, and write the safe code in the main crate.<br />
As an example, see the crates <a href="https://crates.io/crates/openssl">openssl</a> and <a href="https://crates.io/crates/openssl-sys">openssl-sys</a>.</p>
<h3>Writing safe wrappers</h3>
<p>Previously, we imported the C function <code>ssize_t vlc_stream_Read(stream_t *, void *buf, size_t len)</code> as the Rust version <code>pub fn vlc_stream_Read(stream: *mut stream_t, buf: *const c_void, size: size_t) -&amp;gt; ssize_t</code> but kept an unsafe interface. Since we want to use those functions safely, we can now make a better wrapper:</p>
<p>[code lang=C]<br />
use ffi;</p>
<p>pub fn stream_Read(stream: *mut stream_t, buf: &amp;mut [u8]) -&gt; ssize_t {<br />
  unsafe {<br />
    ffi::vlc_stream_Read(stream, buf.as_mut_ptr() as *mut c_void, buf.len())<br />
  }<br />
}<br />
[/code]</p>
<p>Here we replaced the raw pointer to memory and the length with a mutable slice. We still use a raw pointer to the <code>stream_t</code> instance, maybe we can do better:</p>
<p>[code lang=C]<br />
use ffi;</p>
<p>pub struct Stream(*mut stream_t);</p>
<p>pub fn stream_Read(stream: Stream, buf: &amp;mut [u8]) -&gt; ssize_t {<br />
  unsafe {<br />
    ffi::vlc_stream_Read(stream.0, buf.as_mut_ptr() as *mut c_void, buf.len())<br />
  }<br />
}<br />
[/code]</p>
<p>Be careful if you plan to implement <a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>Drop</code></a> for this type: is the Rust code supposed to free that object? Is there some reference counting involved? Here is an example of <code>Drop</code> implementation from the openssl crate:</p>
<p>[code lang=C]<br />
pub struct SslContextBuilder(*mut ffi::SSL_CTX);</p>
<p>impl Drop for SslContextBuilder {<br />
    fn drop(&amp;mut self) {<br />
        unsafe { ffi::SSL_CTX_free(self.as_ptr()) }<br />
    }<br />
}<br />
[/code]</p>
<p>Remember that it's likely the host application has a lot of infrastructure to keep track of memory, and as a rule, we should reuse the tools it offers for the code at the interface between Rust and C. See the <a href="http://jakegoulding.com/rust-ffi-omnibus/">Rust FFI omnibus</a> for more examples of safe wrappers you can write.</p>
<p><em>Side note: as of now (2017/07/10) <a href="https://github.com/rust-lang/rust/issues/32838">custom allocators</a> are still not stable</em></p>
<h2>Exporting Rust code to be called from C</h2>
<p>Since the host application is written in C, it might need to call your code. This is quite easy in Rust: you need to write unsafe wrappers.</p>
<p>Here we will use as example the <a href="https://github.com/Geal/rust-devoxx2016">inverted index library for mobile apps</a> I wrote for a conference. In this library, we have an <code>Index</code> type that we want to use from Java. Here is its definition:</p>
<p>[code lang=C]<br />
#[repr(C)]<br />
pub struct Index {<br />
  pub index: HashMap&lt;String, HashSet&lt;i32&gt;&gt;,<br />
}<br />
[/code]</p>
<p>This type has a few method we want to provide:</p>
<p>[code lang=C]<br />
impl Index {<br />
  pub fn new() -&gt; Index {<br />
    Index {<br />
      index: HashMap::new(),<br />
    }<br />
  }</p>
<p>  pub fn insert(&amp;mut self, id: i32, data: &amp;str) {<br />
    [...]<br />
  }</p>
<p>  pub fn search_word(&amp;self, word: &amp;str) -&gt; Option&lt;&amp;HashSet&lt;i32&gt;&gt; {<br />
    self.index.get(word)<br />
  }</p>
<p>  pub fn search(&amp;self, text: &amp;str) -&gt; HashSet&lt;i32&gt; {<br />
    [...]<br />
  }<br />
}<br />
[/code]</p>
<p>First, we need to write the functions to allocate and deallocate our index. Every use from C will be wrapped in a <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>.</p>
<p>[code lang=C]<br />
#[no_mangle]<br />
pub extern &quot;C&quot; fn index_create() -&gt; *mut Index {<br />
  Box::into_raw(Box::new(Index::new()))<br />
}<br />
[/code]</p>
<p>The <code>Box</code> type indicates and owns a heap allocation. When the box is dropped, the underlying data is dropped as well and the memory is freed. The following function takes ownership of its argument, so it is dropped at the end.</p>
<p>[code lang=C]<br />
#[no_mangle]<br />
pub extern &quot;C&quot; fn index_free(ptr: *mut Index) {<br />
    let _ = unsafe { Box::from_raw(ptr) };<br />
}<br />
[/code]</p>
<p>Now that allocation is handled, we can work on a real method. The following method takes an index, and id for a text, and the text itself, as a C string (ie, terminated by a null character).</p>
<p>Since we're kinda writing C in Rust here, we have to first check if the pointers are null. Then we can transform the C string in a slice. Then we check if it is correctly encoded as UTF-8 before inserting it into our index.</p>
<p>[code lang=C]<br />
#[no_mangle]<br />
pub extern &quot;C&quot; fn index_insert(index: *mut Index, id: i32, raw_text: *const c_char) {<br />
  unsafe { if index.is_null() || raw_text.is_null() { return } };<br />
  let slice = unsafe { CStr::from_ptr(raw_text).to_bytes() };<br />
  if let Ok(text) = str::from_utf8(slice) {<br />
    (*index).insert(id, text);<br />
  }<br />
}<br />
[/code]</p>
<p>Most of the code for those kinds of wrappers is just there to transform between C and Rust types and checking that the arguments coming from C code are correct. Even if we have to trust the host application, we should program defensively at the boundary.</p>
<p>There are <a href="https://github.com/Geal/rust-devoxx2016/blob/master/inverted_index/src/lib.rs#L96-L121">other methods we could implement</a> for the index, we'll leave those as exercise for the reader :)</p>
<p>Now, we need to write the C definitions to import those functions and types:</p>
<p>[code lang=C]<br />
typedef struct Index Index;</p>
<p>Index* index_create();<br />
void   index_free(Index* index);<br />
void   index_insert(Index* index, int32_t id, char const* raw_text);<br />
[/code]</p>
<p>We defined <code>Index</code> as an opaque type here. Since Rust structures can be compatible with C structures, we could export the real type, but since it only contains a Rust specific type, <code>HashMap</code>, it is better to hide it completely and write accessors and wrappers.</p>
<h3>Generating bindings with rusty-cheddar</h3>
<p>Writing function imports from C to Rust is tedious, so we have bindgen for this. We also have a great tool to go the other way: <a href="https://github.com/Sean1708/rusty-cheddar">rusty-cheddar</a>.</p>
<p>In the same way, it can be used from a build script:</p>
<p>[code lang=C]<br />
extern crate cheddar;</p>
<p>fn main() {<br />
  cheddar::Cheddar::new().expect(&quot;could not read definitions&quot;)<br />
    .run_build(&quot;include/main.h&quot;);<br />
  cheddar::Cheddar::new().expect(&quot;could not read definitions&quot;)<br />
    .module(&quot;index&quot;).expect(&quot;malformed module path&quot;)<br />
    .insert_code(&quot;#include \&quot;main.h\&quot;&quot;)<br />
    .run_build(&quot;include/index.h&quot;);<br />
}<br />
[/code]</p>
<p>Here we run rusty-cheddar a first time without specifying the module: it will default to generate a header for the definitions in <code>src/lib.rs</code>.<br />
The second run specifies a different module, and can insert a file inclusion at the top.</p>
<p>It can be a good idea to commit the generated headers, since you will see immediately if you changed the interface in a breaking way.</p>
<h2>Integrating with the build system</h2>
<p>As you might know, we can make dynamic libraries and executables with rustc and cargo. But often, the host application will have its own build system, and it might disagree with the way cargo builds its projects. So we have multiple strategies:</p>
<ul>
<li>build Rust code separately, store libraries and headers in Maven or something (don't laugh, I've worked with such a system once, and it was actually great)</li>
<li>try to let rustc build dynamic libraries from inside the build system. We tried that for VLC and it was not great at all</li>
<li>build a static library from inside or outside the build system, include it in the libraries at link. This was done in <a href="https://github.com/rusticata/rusticata">Rusticata</a></li>
<li>build an object file and let the build system link it. This is what we ended up doing with VLC</li>
</ul>
<p>Building a static library is as easy as specifying <code>crate-type = ["staticlib"]</code> in your <code>Cargo.toml</code> file. To build an object file, use the command <code>cargo rustc --release -- --emit obj</code>. You can see how we added it to the <a href="https://github.com/Geal/vlc/blob/rust/modules/demux/Makefile.am#L464-L477">autotools usage in VLC</a>.</p>
<p>Unfortunately, for this part we still do not have automated ways to fix the issues. Maybe with some time, people will write scripts for autotools,<br />
CMake and others to handle Rust and Cargo.</p>
<p><em>Side note on reproducible builds: if you want to fix the set of Rust dependencies used in your project and make them always available, you can use <a href="https://github.com/alexcrichton/cargo-vendor">cargo-vendor</a> to store them in a specific folder</em></p>
<p>As you might have guessed, this is the most complex part, for which I have no good generic answer. I'd recommend that you spend the most time on this during the project's prototyping phase: import very little C code, export very little Rust code, try to make it build entirely from within the host application's build system. Once this is done, extending the project will get much easier. You really don't want to discover this task at the end of your project and try to retrofit your code in there.</p>
<h2>Going further</h2>
<p>While this article just explores the surface of Rust rewrites, I hope it provides a good starting point on the tools and techniques you can apply.<br />
Any rewrite will be a large and complex project, but the result is worth the effort. The code you will write will be stronger, and Rust's type system will force you to review the assumptions made in the C version. You might even find better ways to write it once you start refactoring your code in a more Rusty way, safely hidden behind your wrappers.</p>

    

    
      
      
      

      
    
  </article>
  
  <article class="post-body">
    <h2 class="post-title">
      <a href="/rust/2017/07/10/why-you-should-actually-rewrite-it-in-rust.html">
        Why you should, actually, rewrite it in Rust
      </a>
    </h2>
    <div class="post-meta">
  <span class="post-date">10 Jul 2017</span>
  <span class="post-categories">
    
      &bull;

      
      
      

      
        <a href="/category/rust.html">
          Rust
        </a>
      
    
  </span>
</div>

    
      <p>You might have seen those obnoxious "you should rewrite it in Rust comments" here and there:</p>
<ul>
<li>in a <a href="https://transitiontech.ca/random/RIIR">blogpost</a></li>
<li>in a <a href="https://github.com/fc00/go-fc00/issues/1">Github issue</a></li>
<li>you might have heard about <a href="http://n-gate.com/hackernews/2017/02/21/0/">that Rust Evangelism Strike Force</a></li>
<li>it even has a joke <a href="https://twitter.com/rustevangelism">twitter account</a></li>
</ul>
<p>It's like at every new memory vulnerability in well known software, there‚Äôs that one person saying Rust would have avoided the issue. We get it, it‚Äôs annoying, and it does not help us grow Rust. This attitude is generally frowned upon in the Rust community. You can't just show up into someone‚Äôs project telling them to rewrite everything.</p>
<p>so, why am I writing this? Why would I try to convince you, now, that you should actually rewrite your software in Rust?</p>
<p>That's because I have been working on this subject for a long time now:</p>
<ul>
<li>I did <a href="https://www.youtube.com/watch?v=YTy_JOxGOd4">multiple</a> <a href="https://www.youtube.com/watch?v=e92Yrp3W_2I">talks</a> on it  </li>
<li>I even co-wrote a <a href="http://spw17.langsec.org/papers.html#parsers2017">paper</a></li>
<li>I did it both as client and personal work</li>
</ul>
<p>So, I'm commited to this, and yes, I believe you should rewrite some code in Rust. But there's a right way to do it.</p>
<h2>Why rewrite stuff?</h2>
<p>Our software systems are built on sand. We got pretty good at maintaining and fixing them over the years, but the cracks are showing. We still have not fixed definitely most of the low level vulnerabilities: stack buffer overflow (yes, those still exist), heap overflow, use after free, double free, off by one; the list goes on. We have some tools, like DEP, ASLR, stack canaries, control flow integrity, fuzzing. Large projects with funding, like Chrome, can resort to sandboxing parts of their application. The rest of us can still run those applications inside a virtual machine. This situation will not improve. <strong>There's a huge amount of old (think 90s), bad quality, barely maintained code that we reuse everywhere endlessly</strong>. The good thing with hardware is that at some point, it gets replaced. Software just gets copied again. Worse, with the development of IoT, a lot of the code that ships will never be updated. It's likely that some of those old libraries will still be there 15, 20 years from now.</p>
<p>Let's not shy away from the issue here. Most of those are written in C or C++ (and usually an old version). It is well known that it is hard to write correct, reliable software in those languages. Think of all the security related things you have to keep track of in a C codebase:</p>
<ul>
<li>pointer arithmetic</li>
<li>allocations and deallocations</li>
<li>data is mutable by default</li>
<li>functions return integers to mean pointers and error codes. Errors can be implicitely ignored</li>
<li>type casts, overflows and underflows are hard to track</li>
<li>buffer bounds in indexing and copying</li>
<li><a href="https://blog.regehr.org/archives/1520">all the undefined behaviours</a></li>
</ul>
<p>Of course, some developers can do this work. Of course, there are sanitizers. But it's an enormous effort to perform everyday for every project.</p>
<p>Those languages are well suited for low level programming, but require extreme care and expertise to avoid most of those issues. And even then, we assume the developers will always be well rested, focused and careful. We're only humans, after all. Note that in 2017, there are still people claiming that a C developer with sufficient expertise would avoid all those issues. It's time we put this idea to rest. Yes, some projects can avoid a lot of vulnerabilities, with a team of good developers, frequent code reviews, a restricted set of features, funding, tools, etc. Most projects cannot. And as I said earlier, a lot of the code is not even maintained.</p>
<p>So we have to do something. We must make our software foundations stronger. That means fixing operating systems, drivers, libraries, command line tools, servers, everything. We might not be able to fix most of it today, or the next year, but maybe 10 years from now the situation will have improved.</p>
<p>Unfortunately, we cannot rewrite everything. If you ever attempted to rewrite a project from scratch, you'd know that while you can avoid some of the mistakes you made before, you will probably <a href="https://daniel.haxx.se/blog/2017/03/27/curl-is-c/">introduce a lot of regressions and new bugs</a>. It's also wrong on the human side: if there are maintainers for the projects, they would need to work on the new and old one at the same time. Worse, you would have to teach them the new approach, the new language (which they might not like), and plan for an upgrade to the new project for all users.</p>
<p>This is not doable, and this is the part most people asking for project rewrites in Rust do not understand. What I'm advocating for is much simpler: <strong>surgically replace weaker parts but keep most of the project intact</strong>.</p>
<h2>How</h2>
<p>Most of the issues will happen around IO and input data handling, so it makes sense to focus on it. It happens there because that's where the code manipulates buffers, parsers, and uses a lot of pointer calculations. It is also the least interesting part for software maintainers, since it is usually not where you add useful features, business logic, etc. And this logic is usually working well, so you do not want to replace it. If we could rewrite a small part of an application or library without disrupting the rest of the code, we would get most of the benefits without the issues of a full rewrite. It is the exact same project, with the same interface, same distribution packaging as before, same developer team. We would just make an annoying part of the software stronger and more maintainable.</p>
<p>This is where Rust comes in. It is focused on providing memory safety, thread safety while keeping the code performant and the developer productive. As such, it is generally easier to get safe, reliable code in production while writing basic Rust, than a competent, well rested C developer using all the tools available could do.</p>
<p>Most of the other safe languages have strong requirements, like a runtime and a garbage collector. And usually, they expect to be the host application (how many languages assume they will handle the process's entry point?). Here, we are guests in someone else's house. We must integrate nicely and quietly.</p>
<p>Rust is a strong candidate for this because:</p>
<ul>
<li>it can easily call C code</li>
<li>it can easily be called by C code (it can export C compatible functions and structures)</li>
<li>it does not need a garbage collector</li>
<li>if you want, it does not even need to handle allocations</li>
<li>the Rust compiler can produce static and dynamic libraries, and even object files</li>
<li>the Rust compiler avoids most of the memory vulnerabilities you get in C (yes, I had to mention it)</li>
</ul>
<p>So you can actually take a piece of C code inside an existing project, import the C structures and functions to access them from Rust, rewrite the code in Rust, export the functions and structures from Rust, compile it and link it with the rest of the project.</p>
<p>If you don't believe it's possible, take a look at these two examples:</p>
<ul>
<li><a href="https://github.com/rusticata/rusticata">Rusticata</a> integrates Rust parsers written with nom in Suricata, an intrusion detection system</li>
<li>a <a href="https://github.com/geal/rust-vlc-demux">VLC media player plugin</a> to parse FLV files, written entirely in Rust </li>
</ul>
<p>You get a lot of benefits from this approach. First, Rust has great package management with Cargo and crates.io. That means you can separate some of the work in different libraries. See as an example the <a href="https://github.com/rusticata">list of parsers</a> from the Rusticata project. You can test them independently, and even reuse them in other projects. The <a href="https://github.com/rust-av/flavors">FLV parser</a> I wrote for VLC can also work in a <a href="https://github.com/sdroege/gst-plugin-rs/tree/master/gst-plugin-flv">Rust GStreamer plugin</a> You can also make a separate library for the glue with the host application. I'm working on <a href="https://github.com/Geal/vlc_module.rs">vlc_module</a> exactly for that purpose: making Rust VLC plugins easier to write.</p>
<p>This approach works well for applications with a plugin oriented architecture, but you can also rewrite core parts of an application or library. The biggest issue is high coupling of C code, but it is usually easy to rewrite bit by bit by keeping a common interface. Whenever you have rewritten some coupled parts of of a project, you can take time to refactor it in a more Rusty way, and leverage the type system to help you. A good example of this is the <a href="https://github.com/carols10cents/rust-out-your-c-talk">rewrite of the Zopfli library from C to Rust</a>.</p>
<p>This brings us to another important part of that infrastructure rewrite work: while we can rewrite part of an existing project without being too intrusive, we can also rewrite a library entirely, keeping exactly the same C API. You can have a Rust library, dynamic or static, with the exact same C header, that you could import in a project to replace the C one. This is a huge result. It's like replacing a load-bearing wall in an existing building. This is not an easy thing to realize, but once it's done, you can improve a lot of projects at once, provided your distribution's package manager supports that replacement, or other projects take the time to upgrade.</p>
<p>This is a lot of work, but every time we advance a little, everybody can benefit from it, and it will add up over the years. So we might as well start now.</p>
<p>Currently, I'm focused on VLC. This is a good target because it's a popular application that's often part of the basic stack of any computer (browser, office suite, media player). So it's a big target. But take a look at the list of dependencies in most web applications, or the dependency graph of common distributions. There is a lot of low hanging fruit there.</p>
<p>Now, how would you actually perform those rewrites? You can <a href="https://unhandledexpression.com/2017/07/12/how-to-rewrite-you-project-in-rust/">check out the next post</a> and <a href="http://spw17.langsec.org/papers/chifflier-parsing-in-2017.pdf">the paper explaining how we did it in Rusticata and VLC</a>.</p>

    

    
      
      
      

      
    
  </article>
  

  
<div class="pagination">
  <a class="pagination-item older"
     href="/page2">
    Older
  </a>
</div>


</div>
    </main>

    <!-- Optional footer content -->

  </body>
</html>
