---
layout: post
title: Fixing the DLL loading vulnerability
date: 2010-08-23 22:34:49.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- General
- Security
- VideoLAN
tags:
- binary planting
- DLL hijacking
- DLL preloading
- security
- vulnerabilities
- windows
meta:
  _edit_last: '3997956'
  _wp_old_slug: ''
  reddit: a:2:{s:5:"count";i:0;s:4:"time";i:1359457089;}
  tagazine-media: a:7:{s:7:"primary";s:0:"";s:6:"images";a:0:{}s:6:"videos";a:0:{}s:11:"image_count";s:1:"0";s:6:"author";s:7:"3997956";s:7:"blog_id";s:8:"11260360";s:9:"mod_stamp";s:19:"2010-08-25
    19:30:26";}
  _oembed_2be84366e7dbdb2e2e2f7518da24a058: "{{unknown}}"
  _oembed_cdd834305ed5d80d6e4aa78ddfb553d2: "{{unknown}}"
  _oembed_4e7c7127187de13a5af19e66a38b17d6: "{{unknown}}"
  _oembed_ffaf42161c5d7de4e74f2c2f4a4e9eb9: "{{unknown}}"
  _oembed_0f71f7fdf6a2f9009daaec8d8cecf6e7: "{{unknown}}"
author:
  login: geaaal
  email: geo.couprie@gmail.com
  display_name: Géal
  first_name: ''
  last_name: ''
---
<p><strong>Update 24/08/2010: Microsoft published an <a href="https://www.microsoft.com/technet/security/advisory/2269637.mspx">advisory</a>, there's an <a href="http://blogs.technet.com/b/srd/archive/2010/08/23/more-information-about-dll-preloading-remote-attack-vector.aspx">article from the MSRC</a> about the preloading DLL vulnerability, and <a href="http://support.microsoft.com/kb/2264107">a tool</a> that fixes the problem. And if you want to know more, there's an <a href="http://msdn.microsoft.com/en-us/library/ff919712(VS.85).aspx">MSDN article</a>.</strong></p>
<p><strong>Update 25/08/2010: if you came here from golem.de, heise.de or h-online.com, good for you! The articles on these websites are blatantly wrong, and their proposed solution doesn't work . You will find here the real solutions, and links to the relevant blog posts and advisories.</strong></p>
<p>Look! <a href="http://www.securityfocus.com/archive/1/513190">A new</a> <a href="http://www.cs.ucdavis.edu/research/tech-reports/2010/CSE-2010-2.pdf">shiny</a> <a href="http://blog.metasploit.com/2010/08/exploiting-dll-hijacking-flaws.html">vulnerability</a>, affecting a lot of Windows applications! OMG OMG OMG we're DOOMED!</p>
<p>&lt;/crazy mode off&gt;</p>
<p>OK, let's get serious. This vulnerability is actually <a href="http://www.securityfocus.com/bid/1699/discuss">a very old one</a>. It is there because the <a href="http://msdn.microsoft.com/en-us/library/ms682586(v=VS.85).aspx">DLL search order</a> includes the current directory (if someone can tell me why, I would be delighted to know that). Here is the search order (source: <a href="http://msdn.microsoft.com/en-us/library/ms682586(v=VS.85).aspx">MSDN</a>):</p>
<blockquote><p>If <strong>SafeDllSearchMode</strong> is enabled, the search order is as follows:</p>
<ol>
<li>The directory from which the application loaded.</li>
<li>The system directory. Use the <a href="http://msdn.microsoft.com/en-us/library/ms724373(v=VS.85).aspx"><strong>GetSystemDirectory</strong></a> function to get the path of this directory.</li>
<li>The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched.</li>
<li>The Windows directory. Use the <a href="http://msdn.microsoft.com/en-us/library/ms724454(v=VS.85).aspx"><strong>GetWindowsDirectory</strong></a> function to get the path of this directory.</li>
<li>The current directory.</li>
<li>The directories that are listed in the PATH environment variable. Note that this does not include the per-application path specified by the <strong>App Paths</strong> registry key. The <strong>App Paths</strong> key is not used when computing the DLL search path.</li>
</ol>
<p>If <strong>SafeDllSearchMode</strong> is disabled, the search order is as follows:</p>
<ol>
<li>The directory from which the application loaded.</li>
<li>The current directory.</li>
<li>The system directory. Use the <a href="http://msdn.microsoft.com/en-us/library/ms724373(v=VS.85).aspx"><strong>GetSystemDirectory</strong></a> function to get the path of this directory.</li>
<li>The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched.</li>
<li>The Windows directory. Use the <a href="http://msdn.microsoft.com/en-us/library/ms724454(v=VS.85).aspx"><strong>GetWindowsDirectory</strong></a> function to get the path of this directory.</li>
</ol>
</blockquote>
<p>For the record: disabling SafeDllSearchMode means that you're stupid, or that you're using a Windows before XP SP1 (note that this is not exclusive).</p>
<p>So, let's assume that your application tries to load a DLL that isn't present, either in your application directory, or in the system directories. Then, the application will try to load the DLL from the current directory. And that's it. If there's a DLL with the same name in that folder, it will be loaded in the application. That's why you can get owned by opening a file in that same directory: it sets the current directory of the application to the file's folder.</p>
<p>OMG OMG OMG we're DOOMED, and it's incredibly easy to exploit me!</p>
<p>So, now, let's take a look at the fix. This is an OS flaw. You can't fix all your applications yourself. H.D. Moore has some <a href="http://blog.rapid7.com/?p=5325">sysadmin fixes</a> that you can apply to prevent the exploit from coming on your computer. But your applications will still be exploitable.</p>
<p>If you're a developer, though, you can fix your application. There's a function that can remove the current directory from the DLL search path: SetDllDirectory. From <a href="http://msdn.microsoft.com/en-us/library/ms686203(VS.85).aspx">MSDN</a>:</p>
<blockquote><p>After calling <strong>SetDllDirectory</strong>, the DLL search path is:</p>
<ol>
<li>The directory from which the application loaded.</li>
<li>The directory specified by the <em>lpPathName</em> parameter.</li>
<li>The system directory. Use the <a href="http://msdn.microsoft.com/en-us/library/ms724373(v=VS.85).aspx"><strong>GetSystemDirectory</strong></a> function to get the path of this directory. The name of this directory is System32.</li>
<li>The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The name of this directory is System.</li>
<li>The Windows directory. Use the <a href="http://msdn.microsoft.com/en-us/library/ms724454(v=VS.85).aspx"><strong>GetWindowsDirectory</strong></a> function to get the path of this directory.</li>
<li>The directories that are listed in the PATH environment variable.</li>
</ol>
</blockquote>
<p>So, if you pass a safe directory(let's say, C:\Windows\System32, or your application directory) as argument to SetDllDirectory, you effectively remove the current directory from the search path! It works, I tested it for you :)</p>
<p>But that's not the end: you have to wipe out the PATH to be safe. <a href="http://blog.metasploit.com/2010/08/exploiting-dll-hijacking-flaws.html">From the metasploit blog</a>:</p>
<blockquote><p>If the application is trying to load a DLL that is normally found within the PATH, but not the Windows system directories, and the PATH contains environment variables that have not been set, then the literal value of the environment variable will be treated as sub-directory of the working directory (the share). For example, if %unknownvariable%\bin is in the system PATH, the share will be searched for a directory called “%unknownvariable%\bin” and the target DLL will be loaded from within this sub-directory.</p></blockquote>
<p>And if you test  your application with ProcMon, you will surely see that a lot of (potentially unsafe) directories are added to the PATH, and used to look for the DLL. So, remove all the useless directories from the PATH if you can!</p>
<p>(And now, for the disclaimer: this blog post is not endorsed by Microsoft, and if you want to be really safe and know the best solution to employ, wait for Microsoft's patches and workarounds. But if you trust me enough (you fool... *evil laugh*), you can try that fix on your application, and maybe protect your users. )</p>
<p>Actually, that fix is encouraged by Microsoft, and David Leblanc wrote about it in February 2008.</p>
